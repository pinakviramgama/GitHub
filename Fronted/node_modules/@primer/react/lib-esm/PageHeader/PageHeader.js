import React, { useEffect } from 'react';
import { useResponsiveValue, isResponsiveValue } from '../hooks/useResponsiveValue.js';
import { ArrowLeftIcon } from '@primer/octicons-react';
import { areAllValuesTheSame, haveRegularAndWideSameValue } from '../utils/getBreakpointDeclarations.js';
import { warning } from '../utils/warning.js';
import { clsx } from 'clsx';
import classes from './PageHeader.module.css.js';
import { toggleSxComponent } from '../internal/utils/toggleSxComponent.js';
import { defaultSxProp } from '../utils/defaultSxProp.js';
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import { useProvidedRefOrCreate } from '../hooks/useProvidedRefOrCreate.js';
import Heading from '../Heading/Heading.js';
import Link from '../Link/Link.js';
import Box from '../Box/Box.js';

// Default state for the `visible` prop when a sub component is only visible on narrow viewport
const hiddenOnRegularAndWide = {
  narrow: false,
  regular: true,
  wide: true
};

// Default state for the `visible` prop when a sub component is visible on regular and wide viewport
const hiddenOnNarrow = {
  narrow: true,
  regular: false,
  wide: false
};

// Root
// -----------------------------------------------------------------------------

const RootBaseComponent = toggleSxComponent('div');
const Root = /*#__PURE__*/React.forwardRef(({
  children,
  className,
  sx = defaultSxProp,
  as = 'div',
  'aria-label': ariaLabel,
  role,
  hasBorder
}, forwardedRef) => {
  const rootRef = useProvidedRefOrCreate(forwardedRef);
  const isInteractive = element => {
    return ['a', 'button'].some(selector => element.matches(selector)) || element.hasAttribute('role') && element.getAttribute('role') === 'button' || element.hasAttribute('link') && element.getAttribute('role') === 'link' || element.hasAttribute('tabindex');
  };
  useEffect(function validateInteractiveElementsInTitle() {
    if (!(process.env.NODE_ENV !== "production")) return;
    let hasContextArea = false;
    let hasLeadingAction = false;
    if (!rootRef.current || rootRef.current.children.length <= 0) return;
    const titleArea = Array.from(rootRef.current.children).find(child => {
      return child instanceof HTMLElement && child.getAttribute('data-component') === 'TitleArea';
    });

    // It is very unlikely to have a PageHeader without a TitleArea, but we still want to make sure we don't break the page if that happens.
    if (!titleArea) return;
    for (const child of React.Children.toArray(children)) {
      if (/*#__PURE__*/React.isValidElement(child) && child.type === ContextArea) {
        hasContextArea = true;
      }
      if (/*#__PURE__*/React.isValidElement(child) && child.type === LeadingAction) {
        hasLeadingAction = true;
      }
    }
    // Check if TitleArea has any interactive children or grandchildren.
    const hasInteractiveContent = Array.from(titleArea.childNodes).some(child => {
      return child instanceof HTMLElement && isInteractive(child) || Array.from(child.childNodes).some(child => {
        return child instanceof HTMLElement && isInteractive(child);
      });
    });
    // PageHeader.TitleArea is be the first element in the DOM even when it is not visually the first.
    // Motivation behind this rule to make sure context area and leading action (if they exist) are always rendered after the title (a heading tag)
    // so that screen reader users who are navigating via heading menu won't miss these actions.
    process.env.NODE_ENV !== "production" ? warning(hasInteractiveContent && (hasContextArea || hasLeadingAction), 'When PageHeader.ContextArea or PageHeader.LeadingAction is present, we recommended not to include any interactive items in the PageHeader.TitleArea to make sure the focus order is logical.') : void 0;
  }, [children, rootRef]);
  return /*#__PURE__*/jsx(RootBaseComponent, {
    as: as,
    ref: rootRef,
    className: clsx(classes.PageHeader, className),
    "data-has-border": hasBorder ? 'true' : undefined,
    sx: sx,
    "aria-label": ariaLabel,
    role: role,
    children: children
  });
});
const ContextAreaBaseComponent = toggleSxComponent('div');
// PageHeader.ContextArea : Only visible on narrow viewports by default to provide user context of where they are at their journey. `hidden` prop available
// to manage their custom visibility but consumers should be careful if they choose to hide this on narrow viewports.
// PageHeader.ContextArea Sub Components: PageHeader.ParentLink, PageHeader.ContextBar, PageHeader.ContextAreaActions
// ---------------------------------------------------------------------
const ContextArea = ({
  children,
  className,
  hidden = hiddenOnRegularAndWide,
  sx: sxProp = defaultSxProp
}) => {
  return /*#__PURE__*/jsx(ContextAreaBaseComponent, {
    className: clsx(classes.ContextArea, className),
    sx: sxProp,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
ContextArea.displayName = "ContextArea";
// PageHeader.ParentLink : Only visible on narrow viewports by default to let users navigate up in the hierarchy.
const ParentLink = /*#__PURE__*/React.forwardRef(({
  children,
  className,
  sx: sxProp = defaultSxProp,
  href,
  'aria-label': ariaLabel,
  as = 'a',
  hidden = hiddenOnRegularAndWide
}, ref) => {
  return /*#__PURE__*/jsx(Fragment, {
    children: /*#__PURE__*/jsxs(Link, {
      ref: ref,
      as: as,
      "aria-label": ariaLabel,
      muted: true,
      className: clsx(classes.ParentLink, className),
      sx: sxProp,
      ...getHiddenDataAttributes(hidden),
      href: href,
      children: [/*#__PURE__*/jsx(ArrowLeftIcon, {}), /*#__PURE__*/jsx(Box, {
        children: children
      })]
    })
  });
});
ParentLink.displayName = 'ParentLink';

// ContextBar
// Generic slot for any component above the title region. Use it for custom breadcrumbs and other navigation elements instead of ParentLink.
// ---------------------------------------------------------------------

const ContextBarBaseComponent = toggleSxComponent('div');
const ContextBar = ({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = hiddenOnRegularAndWide
}) => {
  return /*#__PURE__*/jsx(ContextBarBaseComponent, {
    className: clsx(classes.ContextBar, className),
    sx: sxProp,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
ContextBar.displayName = "ContextBar";
const ContextAreaActionsBaseComponent = toggleSxComponent('div');
// ContextAreaActions
// ---------------------------------------------------------------------
const ContextAreaActions = ({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = hiddenOnRegularAndWide
}) => {
  return /*#__PURE__*/jsx(ContextAreaActionsBaseComponent, {
    className: clsx(classes.ContextAreaActions, className),
    ...getHiddenDataAttributes(hidden),
    sx: sxProp,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
ContextAreaActions.displayName = "ContextAreaActions";
// PageHeader.TitleArea: The main title area of the page. Visible on all viewports.
// PageHeader.TitleArea Sub Components: PageHeader.LeadingVisual, PageHeader.Title, PageTitle.TrailingVisual
// ---------------------------------------------------------------------

const TitleAreaBaseComponent = toggleSxComponent('div');
const TitleArea = /*#__PURE__*/React.forwardRef(({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = false,
  variant = 'medium'
}, forwardedRef) => {
  const titleAreaRef = useProvidedRefOrCreate(forwardedRef);
  const currentVariant = useResponsiveValue(variant, 'medium');
  return /*#__PURE__*/jsx(TitleAreaBaseComponent, {
    className: clsx(classes.TitleArea, className),
    ref: titleAreaRef,
    "data-component": "TitleArea",
    "data-size-variant": currentVariant,
    sx: sxProp,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
});
TitleArea.displayName = 'TitleArea';
const LeadingActionBaseComponent = toggleSxComponent('div');
// PageHeader.LeadingAction and PageHeader.TrailingAction should only be visible on regular viewports.
// So they come as hidden on narrow viewports by default and their visibility can be managed by their `hidden` prop.
const LeadingAction = ({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = hiddenOnNarrow
}) => {
  const style = {};
  // @ts-ignore sx has height attribute
  const {
    height
  } = sxProp;
  if (height) style['--custom-height'] = height;
  return /*#__PURE__*/jsx(LeadingActionBaseComponent, {
    className: clsx(classes.LeadingAction, className),
    "data-component": "PH_LeadingAction",
    sx: sxProp,
    style: style,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
LeadingAction.displayName = "LeadingAction";
const BreadcrumbsBaseComponent = toggleSxComponent('div');
// This is reserved for only breadcrumbs.
const Breadcrumbs = ({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = false
}) => {
  return /*#__PURE__*/jsx(BreadcrumbsBaseComponent, {
    className: clsx(classes.Breadcrumbs, className),
    "data-component": "PH_Breadcrumbs",
    sx: sxProp,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
Breadcrumbs.displayName = "Breadcrumbs";
const LeadingVisualBaseComponent = toggleSxComponent('div');
// PageHeader.LeadingVisual and PageHeader.TrailingVisual should remain visible on narrow viewports.
const LeadingVisual = ({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = false
}) => {
  const style = {};
  // @ts-ignore sx has height attribute
  const {
    height
  } = sxProp;
  if (height) style['--custom-height'] = height;
  return /*#__PURE__*/jsx(LeadingVisualBaseComponent, {
    className: clsx(classes.LeadingVisual, className),
    "data-component": "PH_LeadingVisual",
    sx: sxProp,
    style: style,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
LeadingVisual.displayName = "LeadingVisual";
const Title = ({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = false,
  as = 'h2'
}) => {
  const style = {};
  // @ts-ignore sxProp can have color attribute
  const {
    fontSize,
    lineHeight,
    fontWeight
  } = sxProp;
  if (fontSize) style['--custom-font-size'] = fontSize;
  if (lineHeight) style['--custom-line-height'] = lineHeight;
  if (fontWeight) style['--custom-font-weight'] = fontWeight;
  return /*#__PURE__*/jsx(Heading, {
    className: clsx(classes.Title, className),
    "data-component": "PH_Title",
    "data-hidden": hidden,
    as: as,
    style: style,
    sx: sxProp,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
Title.displayName = "Title";
const TrailingVisualBaseComponent = toggleSxComponent('div');
// PageHeader.LeadingVisual and PageHeader.TrailingVisual should remain visible on narrow viewports.
const TrailingVisual = ({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = false
}) => {
  const style = {};
  // @ts-ignore sx has height attribute
  const {
    height
  } = sxProp;
  if (height) style['--custom-height'] = height;
  return /*#__PURE__*/jsx(TrailingVisualBaseComponent, {
    className: clsx(classes.TrailingVisual, className),
    "data-component": "PH_TrailingVisual",
    sx: sxProp,
    style: style,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
TrailingVisual.displayName = "TrailingVisual";
const TrailingActionBaseComponent = toggleSxComponent('div');
const TrailingAction = ({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = hiddenOnNarrow
}) => {
  const style = {};
  // @ts-ignore sx has height attribute
  const {
    height
  } = sxProp;
  if (height) style['--custom-height'] = height;
  return /*#__PURE__*/jsx(TrailingActionBaseComponent, {
    className: clsx(classes.TrailingAction, className),
    "data-component": "PH_TrailingAction",
    sx: sxProp,
    style: style,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
TrailingAction.displayName = "TrailingAction";
const ActionsBaseComponent = toggleSxComponent('div');
const Actions = ({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = false
}) => {
  const style = {};
  // @ts-ignore sx has height attribute
  const {
    height
  } = sxProp;
  if (height) style['--custom-height'] = height;
  return /*#__PURE__*/jsx(ActionsBaseComponent, {
    className: clsx(classes.Actions, className),
    "data-component": "PH_Actions",
    sx: sxProp,
    style: style,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
Actions.displayName = "Actions";
const DescriptionBaseComponent = toggleSxComponent('div');

// PageHeader.Description: The description area of the header. Visible on all viewports
const Description = ({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = false
}) => {
  return /*#__PURE__*/jsx(DescriptionBaseComponent, {
    className: clsx(classes.Description, className),
    sx: sxProp,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
Description.displayName = "Description";
const NavigationBaseComponent = toggleSxComponent('div');

// PageHeader.Navigation: The local navigation area of the header. Visible on all viewports
const Navigation = ({
  children,
  className,
  sx: sxProp = defaultSxProp,
  hidden = false,
  as,
  'aria-label': ariaLabel,
  'aria-labelledby': ariaLabelledBy
}) => {
  process.env.NODE_ENV !== "production" ? warning(as === 'nav' && !ariaLabel && !ariaLabelledBy, 'Use `aria-label` or `aria-labelledby` prop to provide an accessible label to the `nav` landmark for assistive technology') : void 0;
  return /*#__PURE__*/jsx(NavigationBaseComponent, {
    as: as
    // Render `aria-label` and `aria-labelledby` only on `nav` elements
    ,
    "aria-label": as === 'nav' ? ariaLabel : undefined,
    "aria-labelledby": as === 'nav' ? ariaLabelledBy : undefined,
    className: clsx(classes.Navigation, className),
    "data-component": "PH_Navigation",
    sx: sxProp,
    ...getHiddenDataAttributes(hidden),
    children: children
  });
};
Navigation.displayName = "Navigation";
// Based on getBreakpointDeclarations, this function will return the
// correct data attribute for the given hidden value for CSS modules.
function getHiddenDataAttributes(isHidden) {
  if (isResponsiveValue(isHidden)) {
    const responsiveValue = isHidden;

    // Build media queries with the giving cssProperty and mapFn
    const narrowMediaQuery = 'narrow' in responsiveValue ? {
      'data-hidden-narrow': responsiveValue.narrow || undefined
    } : {};
    const regularMediaQuery = 'regular' in responsiveValue ? {
      'data-hidden-regular': responsiveValue.regular || undefined
    } : {};
    const wideMediaQuery = 'wide' in responsiveValue ? {
      'data-hidden-wide': responsiveValue.wide || undefined
    } : {};

    // check if all values are the same - this is not a recommended practice but we still should check for it
    if (areAllValuesTheSame(responsiveValue)) {
      // if all the values are the same, we can just use one of the value to determine the CSS property's value
      return {
        'data-hidden-all': responsiveValue.narrow || undefined
      };
      // check if regular and wide have the same value, if so we can just return the narrow and regular media queries
    } else if (haveRegularAndWideSameValue(responsiveValue)) {
      return {
        ...narrowMediaQuery,
        ...regularMediaQuery
      };
    } else {
      return {
        ...narrowMediaQuery,
        ...regularMediaQuery,
        ...wideMediaQuery
      };
    }
  } else {
    // If the given value is not a responsive value
    return {
      'data-hidden-all': isHidden || undefined
    };
  }
}
const PageHeader = Object.assign(Root, {
  ContextArea,
  ParentLink,
  ContextBar,
  TitleArea,
  ContextAreaActions,
  LeadingAction,
  Breadcrumbs,
  LeadingVisual,
  Title,
  TrailingVisual,
  TrailingAction,
  Actions,
  Description,
  Navigation
});
PageHeader.displayName = 'PageHeader';

export { PageHeader };
