import { FileDirectoryOpenFillIcon, FileDirectoryFillIcon, ChevronDownIcon, ChevronRightIcon } from '@primer/octicons-react';
import { clsx } from 'clsx';
import React, { useCallback, useEffect } from 'react';
import classes from './TreeView.module.css.js';
import { ConfirmationDialog } from '../ConfirmationDialog/ConfirmationDialog.js';
import VisuallyHidden from '../_VisuallyHidden.js';
import { useControllableState } from '../hooks/useControllableState.js';
import { useId } from '../hooks/useId.js';
import useSafeTimeout from '../hooks/useSafeTimeout.js';
import { useSlots } from '../hooks/useSlots.js';
import { getAccessibleName } from './shared.js';
import { useRovingTabIndex, getFirstChildElement } from './useRovingTabIndex.js';
import { useTypeahead } from './useTypeahead.js';
import { SkeletonAvatar } from '../experimental/Skeleton/SkeletonAvatar.js';
import { SkeletonText } from '../experimental/Skeleton/SkeletonText.js';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import StyledSpinner from '../Spinner/Spinner.js';
import Text from '../Text/Text.js';

const RootContext = /*#__PURE__*/React.createContext({
  announceUpdate: () => {},
  expandedStateCache: {
    current: new Map()
  }
});
const ItemContext = /*#__PURE__*/React.createContext({
  itemId: '',
  level: 1,
  isSubTreeEmpty: false,
  setIsSubTreeEmpty: () => {},
  isExpanded: false,
  setIsExpanded: () => {},
  leadingVisualId: '',
  trailingVisualId: ''
});

// ----------------------------------------------------------------------------
// TreeView

/* Size of toggle icon in pixels. */
const TOGGLE_ICON_SIZE = 12;
const Root = ({
  'aria-label': ariaLabel,
  'aria-labelledby': ariaLabelledby,
  children,
  flat,
  truncate = true,
  className,
  style
}) => {
  const containerRef = React.useRef(null);
  const mouseDownRef = React.useRef(false);
  const [ariaLiveMessage, setAriaLiveMessage] = React.useState('');
  const announceUpdate = React.useCallback(message => {
    setAriaLiveMessage(message);
  }, []);
  const onMouseDown = useCallback(() => {
    mouseDownRef.current = true;
  }, []);
  useEffect(() => {
    function onMouseUp() {
      mouseDownRef.current = false;
    }
    document.addEventListener('mouseup', onMouseUp);
    return () => {
      document.removeEventListener('mouseup', onMouseUp);
    };
  }, []);
  useRovingTabIndex({
    containerRef,
    mouseDownRef
  });
  useTypeahead({
    containerRef,
    onFocusChange: element => {
      if (element instanceof HTMLElement) {
        element.focus();
      }
    }
  });
  const expandedStateCache = React.useRef(null);
  if (expandedStateCache.current === null) {
    expandedStateCache.current = new Map();
  }
  return /*#__PURE__*/jsx(RootContext.Provider, {
    value: {
      announceUpdate,
      expandedStateCache
    },
    children: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(VisuallyHidden, {
        role: "status",
        "aria-live": "polite",
        "aria-atomic": "true",
        children: ariaLiveMessage
      }), /*#__PURE__*/jsx("ul", {
        ref: containerRef,
        role: "tree",
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledby,
        "data-omit-spacer": flat,
        "data-truncate-text": truncate || false,
        onMouseDown: onMouseDown,
        className: clsx(className, classes.TreeViewRootUlStyles),
        style: style,
        children: children
      })]
    })
  });
};
Root.displayName = "Root";
Root.displayName = 'TreeView';

// ----------------------------------------------------------------------------
// TreeView.Item

const Item = /*#__PURE__*/React.forwardRef(({
  id: itemId,
  containIntrinsicSize,
  current: isCurrentItem = false,
  defaultExpanded,
  expanded,
  onExpandedChange,
  onSelect,
  children,
  className,
  'aria-label': ariaLabel,
  'aria-labelledby': ariaLabelledby
}, ref) => {
  const [slots, rest] = useSlots(children, {
    leadingAction: LeadingAction,
    leadingVisual: LeadingVisual,
    trailingVisual: TrailingVisual
  });
  const {
    expandedStateCache
  } = React.useContext(RootContext);
  const labelId = useId();
  const leadingVisualId = useId();
  const trailingVisualId = useId();
  const [isExpanded, setIsExpanded] = useControllableState({
    name: itemId,
    // If the item was previously mounted, its expanded state might be cached.
    // We check the cache first, and then fall back to the defaultExpanded prop.
    // If defaultExpanded is not provided, we default to false unless the item
    // is the current item, in which case we default to true.
    defaultValue: () => {
      var _ref, _expandedStateCache$c, _expandedStateCache$c2;
      return (_ref = (_expandedStateCache$c = (_expandedStateCache$c2 = expandedStateCache.current) === null || _expandedStateCache$c2 === void 0 ? void 0 : _expandedStateCache$c2.get(itemId)) !== null && _expandedStateCache$c !== void 0 ? _expandedStateCache$c : defaultExpanded) !== null && _ref !== void 0 ? _ref : isCurrentItem;
    },
    value: expanded === null ? false : expanded,
    onChange: onExpandedChange
  });
  const {
    level
  } = React.useContext(ItemContext);
  const {
    hasSubTree,
    subTree,
    childrenWithoutSubTree
  } = useSubTree(rest);
  const [isSubTreeEmpty, setIsSubTreeEmpty] = React.useState(!hasSubTree);
  const [isFocused, setIsFocused] = React.useState(false);

  // Set the expanded state and cache it
  const setIsExpandedWithCache = React.useCallback(newIsExpanded => {
    var _expandedStateCache$c3;
    setIsExpanded(newIsExpanded);
    (_expandedStateCache$c3 = expandedStateCache.current) === null || _expandedStateCache$c3 === void 0 ? void 0 : _expandedStateCache$c3.set(itemId, newIsExpanded);
  }, [itemId, setIsExpanded, expandedStateCache]);

  // Expand or collapse the subtree
  const toggle = React.useCallback(event => {
    setIsExpandedWithCache(!isExpanded);
    event === null || event === void 0 ? void 0 : event.stopPropagation();
  }, [isExpanded, setIsExpandedWithCache]);
  const handleKeyDown = React.useCallback(event => {
    switch (event.key) {
      case 'Enter':
      case ' ':
        if (onSelect) {
          onSelect(event);
        } else {
          toggle(event);
        }
        event.stopPropagation();
        break;
      case 'ArrowRight':
        // Ignore if modifier keys are pressed
        if (event.altKey || event.metaKey) return;
        event.preventDefault();
        event.stopPropagation();
        setIsExpandedWithCache(true);
        break;
      case 'ArrowLeft':
        // Ignore if modifier keys are pressed
        if (event.altKey || event.metaKey) return;
        event.preventDefault();
        event.stopPropagation();
        setIsExpandedWithCache(false);
        break;
    }
  }, [onSelect, setIsExpandedWithCache, toggle]);
  const ariaDescribedByIds = [slots.leadingVisual ? leadingVisualId : null, slots.trailingVisual ? trailingVisualId : null].filter(Boolean);
  return /*#__PURE__*/jsx(ItemContext.Provider, {
    value: {
      itemId,
      level: level + 1,
      isSubTreeEmpty,
      setIsSubTreeEmpty,
      isExpanded,
      setIsExpanded: setIsExpandedWithCache,
      leadingVisualId,
      trailingVisualId
    },
    children: /*#__PURE__*/jsxs("li", {
      className: clsx('PRIVATE_TreeView-item', className, classes.TreeViewItem),
      ref: ref,
      tabIndex: 0,
      id: itemId,
      role: "treeitem",
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabel ? undefined : ariaLabelledby || labelId,
      "aria-describedby": ariaDescribedByIds.length ? ariaDescribedByIds.join(' ') : undefined,
      "aria-level": level,
      "aria-expanded": isSubTreeEmpty && (!isExpanded || !hasSubTree) || expanded === null ? undefined : isExpanded,
      "aria-current": isCurrentItem ? 'true' : undefined,
      "aria-selected": isFocused ? 'true' : 'false',
      "data-has-leading-action": slots.leadingAction ? true : undefined,
      onKeyDown: handleKeyDown,
      onFocus: event => {
        var _event$currentTarget$;
        // Scroll the first child into view when the item receives focus
        (_event$currentTarget$ = event.currentTarget.firstElementChild) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.scrollIntoView({
          block: 'nearest',
          inline: 'nearest'
        });

        // Set the focused state
        setIsFocused(true);

        // Prevent focus event from bubbling up to parent items
        event.stopPropagation();
      },
      onBlur: () => setIsFocused(false),
      onClick: event => {
        if (onSelect) {
          onSelect(event);
        } else {
          toggle(event);
        }
        event.stopPropagation();
      },
      onAuxClick: event => {
        if (onSelect && event.button === 1) {
          onSelect(event);
        }
        event.stopPropagation();
      },
      children: [/*#__PURE__*/jsxs("div", {
        className: clsx('PRIVATE_TreeView-item-container', classes.TreeViewItemContainer),
        style: {
          // @ts-ignore CSS custom property
          '--level': level,
          contentVisibility: containIntrinsicSize ? 'auto' : undefined,
          containIntrinsicSize
        },
        children: [/*#__PURE__*/jsx("div", {
          style: {
            gridArea: 'spacer',
            display: 'flex'
          },
          children: /*#__PURE__*/jsx(LevelIndicatorLines, {
            level: level
          })
        }), slots.leadingAction, hasSubTree ?
        /*#__PURE__*/
        // This lint rule is disabled due to the guidelines in the `TreeView` api docs.
        // https://github.com/github/primer/blob/main/apis/tree-view-api.md#the-expandcollapse-chevron-toggle
        // This has specific advice that the chevron be available only to pointer event.
        // If they take up a button role, they become unnecessary and numerous tab stops.
        jsx("div", {
          className: clsx('PRIVATE_TreeView-item-toggle', onSelect && 'PRIVATE_TreeView-item-toggle--hover', level === 1 && 'PRIVATE_TreeView-item-toggle--end', classes.TreeViewItemToggle, classes.TreeViewItemToggleHover, classes.TreeViewItemToggleEnd),
          onClick: event => {
            if (onSelect) {
              toggle(event);
            }
          },
          children: isExpanded ? /*#__PURE__*/jsx(ChevronDownIcon, {
            size: TOGGLE_ICON_SIZE
          }) : /*#__PURE__*/jsx(ChevronRightIcon, {
            size: TOGGLE_ICON_SIZE
          })
        }) : null, /*#__PURE__*/jsxs("div", {
          id: labelId,
          className: clsx('PRIVATE_TreeView-item-content', classes.TreeViewItemContent),
          children: [slots.leadingVisual, /*#__PURE__*/jsx("span", {
            className: clsx('PRIVATE_TreeView-item-content-text', classes.TreeViewItemContentText),
            children: childrenWithoutSubTree
          }), slots.trailingVisual]
        })]
      }), subTree]
    })
  });
});

/** Lines to indicate the depth of an item in a TreeView */
const LevelIndicatorLines = ({
  level
}) => {
  return /*#__PURE__*/jsx("div", {
    style: {
      width: '100%',
      display: 'flex'
    },
    children: Array.from({
      length: level - 1
    }).map((_, index) => /*#__PURE__*/jsx("div", {
      className: clsx('PRIVATE_TreeView-item-level-line', classes.TreeViewItemLevelLine)
    }, index))
  });
};
LevelIndicatorLines.displayName = "LevelIndicatorLines";
Item.displayName = 'TreeView.Item';

// ----------------------------------------------------------------------------
// TreeView.SubTree

const SubTree = ({
  count,
  state,
  children,
  'aria-label': ariaLabel
}) => {
  const {
    announceUpdate
  } = React.useContext(RootContext);
  const {
    itemId,
    isExpanded,
    isSubTreeEmpty,
    setIsSubTreeEmpty
  } = React.useContext(ItemContext);
  const loadingItemRef = React.useRef(null);
  const ref = React.useRef(null);
  const [loadingFocused, setLoadingFocused] = React.useState(false);
  const [subTreeLabel, setSubTreeLabel] = React.useState('');
  const previousState = usePreviousValue(state);
  const {
    safeSetTimeout
  } = useSafeTimeout();
  React.useEffect(() => {
    // If `state` is undefined, we're working in a synchronous context and need
    // to detect if the sub-tree has content. If `state === 'done` then we're
    // working in an asynchronous context and need to see if there is content
    // that has been loaded in.
    if (state === undefined || state === 'done') {
      if (!isSubTreeEmpty && !children) {
        setIsSubTreeEmpty(true);
      } else if (isSubTreeEmpty && children) {
        setIsSubTreeEmpty(false);
      }
    }
  }, [state, isSubTreeEmpty, setIsSubTreeEmpty, children]);

  // Handle transition from loading to done state
  React.useEffect(() => {
    const parentElement = document.getElementById(itemId);
    if (!parentElement) return;
    setSubTreeLabel(getAccessibleName(parentElement));
    if (previousState === 'loading' && state === 'done') {
      var _ref$current;
      // Announce update to screen readers
      const parentName = getAccessibleName(parentElement);
      if ((_ref$current = ref.current) !== null && _ref$current !== void 0 && _ref$current.childElementCount) {
        announceUpdate(`${parentName} content loaded`);
      } else {
        announceUpdate(`${parentName} is empty`);
      }

      // Move focus to the first child if the loading indicator
      // was focused when the async items finished loading
      if (loadingFocused) {
        const firstChild = getFirstChildElement(parentElement);
        if (firstChild) {
          safeSetTimeout(() => {
            firstChild.focus();
          });
        } else {
          safeSetTimeout(() => {
            parentElement.focus();
          });
        }
        setLoadingFocused(false);
      }
    } else if (state === 'loading') {
      const parentName = getAccessibleName(parentElement);
      announceUpdate(`${parentName} content loading`);
    }
  }, [loadingFocused, previousState, state, itemId, announceUpdate, ref, safeSetTimeout]);

  // Track focus on the loading indicator
  React.useEffect(() => {
    function handleFocus() {
      setLoadingFocused(true);
    }
    function handleBlur(event) {
      // Skip blur events that are caused by the element being removed from the DOM.
      // This can happen when the loading indicator is focused when async items are
      // done loading and the loading indicator is removed from the DOM.
      // If `loadingFocused` is `true` when `state` is `"done"` then the loading indicator
      // was focused when the async items finished loading and we need to move focus to the
      // first child.
      if (!event.relatedTarget) return;
      setLoadingFocused(false);
    }
    const loadingElement = loadingItemRef.current;
    if (!loadingElement) return;
    loadingElement.addEventListener('focus', handleFocus);
    loadingElement.addEventListener('blur', handleBlur);
    return () => {
      loadingElement.removeEventListener('focus', handleFocus);
      loadingElement.removeEventListener('blur', handleBlur);
    };
  }, [loadingItemRef, state]);
  if (!isExpanded) {
    return null;
  }
  return /*#__PURE__*/jsxs("ul", {
    role: "group",
    style: {
      listStyle: 'none',
      padding: 0,
      margin: 0
    }
    // @ts-ignore Box doesn't have type support for `ref` used in combination with `as`
    ,
    ref: ref,
    "aria-label": ariaLabel || subTreeLabel,
    children: [state === 'loading' ? /*#__PURE__*/jsx(LoadingItem, {
      ref: loadingItemRef,
      count: count
    }) : children, isSubTreeEmpty && state !== 'loading' ? /*#__PURE__*/jsx(EmptyItem, {}) : null]
  });
};
SubTree.displayName = "SubTree";
SubTree.displayName = 'TreeView.SubTree';
function usePreviousValue(value) {
  const ref = React.useRef(value);
  React.useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
const SkeletonItem = () => {
  return /*#__PURE__*/jsxs("span", {
    className: clsx(classes.TreeViewSkeletonItemContainerStyle, classes.TreeViewItemSkeleton, 'PRIVATE_TreeView-item-skeleton'),
    children: [/*#__PURE__*/jsx(SkeletonAvatar, {
      size: 16,
      square: true
    }), /*#__PURE__*/jsx(SkeletonText, {
      className: classes.TreeItemSkeletonTextStyles
    })]
  });
};
SkeletonItem.displayName = "SkeletonItem";
const LoadingItem = /*#__PURE__*/React.forwardRef(({
  count
}, ref) => {
  const itemId = useId();
  if (count) {
    return /*#__PURE__*/jsxs(Item, {
      id: itemId,
      ref: ref,
      children: [Array.from({
        length: count
      }).map((_, i) => {
        return /*#__PURE__*/jsx(SkeletonItem, {
          "aria-hidden": true
        }, i);
      }), /*#__PURE__*/jsxs("div", {
        className: clsx('PRIVATE_VisuallyHidden', classes.TreeViewVisuallyHidden),
        children: ["Loading ", count, " items"]
      })]
    });
  }
  return /*#__PURE__*/jsxs(Item, {
    id: itemId,
    ref: ref,
    children: [/*#__PURE__*/jsx(LeadingVisual, {
      children: /*#__PURE__*/jsx(StyledSpinner, {
        size: "small"
      })
    }), /*#__PURE__*/jsx(Text, {
      className: "fgColor-muted",
      children: "Loading..."
    })]
  });
});
const EmptyItem = /*#__PURE__*/React.forwardRef((props, ref) => {
  return /*#__PURE__*/jsx(Item, {
    expanded: null,
    id: useId(),
    ref: ref,
    children: /*#__PURE__*/jsx(Text, {
      className: "fgColor-muted",
      children: "No items found"
    })
  });
});
function useSubTree(children) {
  return React.useMemo(() => {
    const subTree = React.Children.toArray(children).find(child => /*#__PURE__*/React.isValidElement(child) && child.type === SubTree);
    const childrenWithoutSubTree = React.Children.toArray(children).filter(child => !(/*#__PURE__*/React.isValidElement(child) && child.type === SubTree));
    return {
      subTree,
      childrenWithoutSubTree,
      hasSubTree: Boolean(subTree)
    };
  }, [children]);
}

// ----------------------------------------------------------------------------
// TreeView.LeadingVisual and TreeView.TrailingVisual

const LeadingVisual = props => {
  const {
    isExpanded,
    leadingVisualId
  } = React.useContext(ItemContext);
  const children = typeof props.children === 'function' ? props.children({
    isExpanded
  }) : props.children;
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx("div", {
      className: clsx('PRIVATE_VisuallyHidden', classes.TreeViewVisuallyHidden),
      "aria-hidden": true,
      id: leadingVisualId,
      children: props.label
    }), /*#__PURE__*/jsx("div", {
      className: clsx('PRIVATE_TreeView-item-visual', classes.TreeViewItemVisual),
      "aria-hidden": true,
      children: children
    })]
  });
};
LeadingVisual.displayName = 'TreeView.LeadingVisual';
const TrailingVisual = props => {
  const {
    isExpanded,
    trailingVisualId
  } = React.useContext(ItemContext);
  const children = typeof props.children === 'function' ? props.children({
    isExpanded
  }) : props.children;
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx("div", {
      className: clsx('PRIVATE_VisuallyHidden', classes.TreeViewVisuallyHidden),
      "aria-hidden": true,
      id: trailingVisualId,
      children: props.label
    }), /*#__PURE__*/jsx("div", {
      className: clsx('PRIVATE_TreeView-item-visual', classes.TreeViewItemVisual),
      "aria-hidden": true,
      children: children
    })]
  });
};
TrailingVisual.displayName = 'TreeView.TrailingVisual';

// ----------------------------------------------------------------------------
// TreeView.LeadingAction

const LeadingAction = props => {
  const {
    isExpanded
  } = React.useContext(ItemContext);
  const children = typeof props.children === 'function' ? props.children({
    isExpanded
  }) : props.children;
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx("div", {
      className: clsx('PRIVATE_VisuallyHidden', classes.TreeViewVisuallyHidden),
      "aria-hidden": true,
      children: props.label
    }), /*#__PURE__*/jsx("div", {
      className: clsx('PRIVATE_TreeView-item-leading-action', classes.TreeViewItemLeadingAction),
      "aria-hidden": true,
      children: children
    })]
  });
};
LeadingAction.displayName = 'TreeView.LeadingAction';
// ----------------------------------------------------------------------------
// TreeView.DirectoryIcon

const DirectoryIcon = () => {
  const {
    isExpanded
  } = React.useContext(ItemContext);
  const Icon = isExpanded ? FileDirectoryOpenFillIcon : FileDirectoryFillIcon;
  return /*#__PURE__*/jsx("div", {
    className: clsx('PRIVATE_TreeView-directory-icon', classes.TreeViewDirectoryIcon),
    children: /*#__PURE__*/jsx(Icon, {})
  });
};
DirectoryIcon.displayName = "DirectoryIcon"; // ----------------------------------------------------------------------------
// TreeView.ErrorDialog
const ErrorDialog = ({
  title = 'Error',
  children,
  onRetry,
  onDismiss
}) => {
  const {
    itemId,
    setIsExpanded
  } = React.useContext(ItemContext);
  return /*#__PURE__*/jsx("div", {
    onKeyDown: event => {
      if (['Backspace', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Enter'].includes(event.key)) {
        // Prevent keyboard events from bubbling up to the TreeView
        // and interfering with keyboard navigation
        event.stopPropagation();
      }
    },
    children: /*#__PURE__*/jsx(ConfirmationDialog, {
      title: title,
      onClose: gesture => {
        // Focus parent item after the dialog is closed
        setTimeout(() => {
          const parentElement = document.getElementById(itemId);
          parentElement === null || parentElement === void 0 ? void 0 : parentElement.focus();
        });
        if (gesture === 'confirm') {
          onRetry === null || onRetry === void 0 ? void 0 : onRetry();
        } else {
          setIsExpanded(false);
          onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss();
        }
      },
      confirmButtonContent: "Retry",
      cancelButtonContent: "Dismiss",
      children: children
    })
  });
};
ErrorDialog.displayName = "ErrorDialog";
ErrorDialog.displayName = 'TreeView.ErrorDialog';

// ----------------------------------------------------------------------------
// Export

const TreeView = Object.assign(Root, {
  Item,
  SubTree,
  LeadingAction,
  LeadingVisual,
  TrailingVisual,
  DirectoryIcon,
  ErrorDialog
});

export { TreeView };
