import React, { useRef, useState } from 'react';
import SegmentedControlButton from './SegmentedControlButton.js';
import { SegmentedControlIconButton } from './SegmentedControlIconButton.js';
import { ActionList } from '../ActionList/index.js';
import { useTheme } from '../ThemeProvider.js';
import { useResponsiveValue } from '../hooks/useResponsiveValue.js';
import { defaultSxProp } from '../utils/defaultSxProp.js';
import { isElement } from 'react-is';
import classes from './SegmentedControl.module.css.js';
import { clsx } from 'clsx';
import { BoxWithFallback } from '../internal/components/BoxWithFallback.js';
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import { ActionMenu } from '../ActionMenu/ActionMenu.js';

const Root = ({
  'aria-label': ariaLabel,
  'aria-labelledby': ariaLabelledby,
  children,
  fullWidth,
  onChange,
  size,
  sx: sxProp = defaultSxProp,
  variant = 'default',
  className,
  ...rest
}) => {
  const segmentedControlContainerRef = useRef(null);
  const {
    theme
  } = useTheme();
  const isUncontrolled = onChange === undefined || React.Children.toArray(children).some(child => /*#__PURE__*/React.isValidElement(child) && child.props.defaultSelected !== undefined);
  const responsiveVariant = useResponsiveValue(variant, 'default');
  const isFullWidth = useResponsiveValue(fullWidth, false);
  const selectedSegments = React.Children.toArray(children).map(child => /*#__PURE__*/React.isValidElement(child) && (child.props.defaultSelected || child.props.selected));
  const hasSelectedButton = selectedSegments.some(isSelected => isSelected);
  const selectedIndexExternal = hasSelectedButton ? selectedSegments.indexOf(true) : 0;
  const [selectedIndexInternalState, setSelectedIndexInternalState] = useState(selectedIndexExternal);
  const selectedIndex = isUncontrolled ? selectedIndexInternalState : selectedIndexExternal;
  const selectedChild = /*#__PURE__*/React.isValidElement(React.Children.toArray(children)[selectedIndex]) ? React.Children.toArray(children)[selectedIndex] : undefined;
  const getChildIcon = childArg => {
    if (/*#__PURE__*/React.isValidElement(childArg) && childArg.type === SegmentedControlButton && childArg.props.leadingIcon) {
      if (isElement(childArg.props.leadingIcon)) {
        return childArg.props.leadingIcon;
      } else {
        const LeadingIcon = childArg.props.leadingIcon;
        return /*#__PURE__*/jsx(LeadingIcon, {});
      }
    }
    if (/*#__PURE__*/React.isValidElement(childArg) && childArg.type === SegmentedControlIconButton) {
      if (isElement(childArg.props.icon)) {
        childArg.props.icon;
      } else {
        const Icon = childArg.props.icon;
        return /*#__PURE__*/jsx(Icon, {});
      }
    }
    return null;
  };
  const getChildText = childArg => {
    if (/*#__PURE__*/React.isValidElement(childArg) && childArg.type === SegmentedControlButton) {
      return childArg.props.children;
    }
    return /*#__PURE__*/React.isValidElement(childArg) ? childArg.props['aria-label'] : null;
  };
  if (!ariaLabel && !ariaLabelledby) {
    // eslint-disable-next-line no-console
    console.warn('Use the `aria-label` or `aria-labelledby` prop to provide an accessible label for assistive technologies');
  }
  return responsiveVariant === 'dropdown' ?
  /*#__PURE__*/
  // Render the 'dropdown' variant of the SegmentedControlButton or SegmentedControlIconButton
  jsx(Fragment, {
    children: /*#__PURE__*/jsxs(ActionMenu, {
      children: [/*#__PURE__*/jsx(ActionMenu.Button, {
        "aria-label": ariaLabel && `${getChildText(selectedChild)}, ${ariaLabel}`,
        leadingVisual: getChildIcon(selectedChild),
        children: getChildText(selectedChild)
      }), /*#__PURE__*/jsx(ActionMenu.Overlay, {
        "aria-labelledby": ariaLabelledby,
        children: /*#__PURE__*/jsx(ActionList, {
          selectionVariant: "single",
          children: React.Children.map(children, (child, index) => {
            const ChildIcon = getChildIcon(child);
            // Not a valid child element - skip rendering
            if (! /*#__PURE__*/React.isValidElement(child)) {
              return null;
            }
            return /*#__PURE__*/jsxs(ActionList.Item, {
              selected: index === selectedIndex,
              onSelect: event => {
                isUncontrolled && setSelectedIndexInternalState(index);
                onChange && onChange(index);
                child.props.onClick && child.props.onClick(event);
              },
              children: [ChildIcon, " ", getChildText(child)]
            }, `segmented-control-action-btn-${index}`);
          })
        })
      })]
    })
  }) :
  /*#__PURE__*/
  // Render a segmented control
  jsx(BoxWithFallback, {
    as: "ul",
    sx: sxProp,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledby,
    ref: segmentedControlContainerRef,
    className: clsx(classes.SegmentedControl, className),
    "data-full-width": isFullWidth || undefined,
    "data-size": size,
    ...rest,
    children: React.Children.map(children, (child, index) => {
      // Not a valid child element - skip rendering child
      if (! /*#__PURE__*/React.isValidElement(child)) {
        return null;
      }
      const sharedChildProps = {
        onClick: onChange ? event => {
          onChange(index);
          isUncontrolled && setSelectedIndexInternalState(index);
          child.props.onClick && child.props.onClick(event);
        } : event => {
          child.props.onClick && child.props.onClick(event);
          isUncontrolled && setSelectedIndexInternalState(index);
        },
        selected: index === selectedIndex,
        style: {
          '--separator-color': index === selectedIndex || index === selectedIndex - 1 ? 'transparent' : theme === null || theme === void 0 ? void 0 : theme.colors.border.default,
          ...child.props.style
        },
        sx: child.props.sx
      };

      // Render the 'hideLabels' variant of the SegmentedControlButton
      if (responsiveVariant === 'hideLabels' && /*#__PURE__*/React.isValidElement(child) && child.type === SegmentedControlButton) {
        const {
          'aria-label': childAriaLabel,
          leadingIcon,
          children: childPropsChildren,
          ...restChildProps
        } = child.props;
        const {
          sx: sharedSxProp,
          ...restSharedChildProps
        } = sharedChildProps;
        if (!leadingIcon) {
          // eslint-disable-next-line no-console
          console.warn('A `leadingIcon` prop is required when hiding visible labels');
        } else {
          return /*#__PURE__*/jsx(SegmentedControlIconButton, {
            "aria-label": childAriaLabel || childPropsChildren,
            icon: leadingIcon,
            sx: {
              ...sharedSxProp,
              // setting width here avoids having to pass `isFullWidth` directly to child components
              width: !isFullWidth ? '32px' : '100%' // TODO: use primitive `control.medium.size` when it is available instead of '32px'
            },
            ...restSharedChildProps,
            ...restChildProps
          });
        }
      }

      // Render the children as-is and add the shared child props
      return /*#__PURE__*/React.cloneElement(child, sharedChildProps);
    })
  });
};
Root.displayName = 'SegmentedControl';
const SegmentedControl = Object.assign(Root, {
  Button: SegmentedControlButton,
  IconButton: SegmentedControlIconButton
});

export { SegmentedControl };
