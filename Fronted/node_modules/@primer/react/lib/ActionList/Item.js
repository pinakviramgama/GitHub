'use strict';

var React = require('react');
var useId = require('../hooks/useId.js');
var useSlots = require('../hooks/useSlots.js');
var defaultSxProp = require('../utils/defaultSxProp.js');
var ActionListContainerContext = require('./ActionListContainerContext.js');
var Description = require('./Description.js');
var Group = require('./Group.js');
var Selection = require('./Selection.js');
var Visuals = require('./Visuals.js');
var shared = require('./shared.js');
var TrailingAction = require('./TrailingAction.js');
var ConditionalWrapper = require('../internal/components/ConditionalWrapper.js');
var invariant = require('../utils/invariant.js');
var _VisuallyHidden = require('../_VisuallyHidden.js');
var ActionList_module = require('./ActionList.module.css.js');
var clsx = require('clsx');
var BoxWithFallback = require('../internal/components/BoxWithFallback.js');
var jsxRuntime = require('react/jsx-runtime');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

const SubItem = ({
  children
}) => {
  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: children
  });
};
SubItem.displayName = 'ActionList.SubItem';
const ButtonItemContainerNoBox = /*#__PURE__*/React__default.default.forwardRef(({
  children,
  style,
  ...props
}, forwardedRef) => {
  return /*#__PURE__*/jsxRuntime.jsx("button", {
    type: "button",
    ref: forwardedRef,
    style: style,
    ...props,
    children: children
  });
});
const DivItemContainerNoBox = /*#__PURE__*/React__default.default.forwardRef(({
  children,
  ...props
}, forwardedRef) => {
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    ref: forwardedRef,
    ...props,
    children: children
  });
});
const Item = /*#__PURE__*/React__default.default.forwardRef(({
  variant = 'default',
  disabled = false,
  inactiveText,
  selected = undefined,
  active = false,
  onSelect: onSelectUser,
  sx: sxProp = defaultSxProp.defaultSxProp,
  id,
  role,
  loading,
  _PrivateItemWrapper,
  className,
  groupId: _groupId,
  renderItem: _renderItem,
  handleAddItem: _handleAddItem,
  ...props
}, forwardedRef) => {
  var _slots$trailingVisual, _slots$description$pr, _slots$description;
  const baseSlots = {
    leadingVisual: Visuals.LeadingVisual,
    trailingVisual: Visuals.TrailingVisual,
    trailingAction: TrailingAction.TrailingAction,
    subItem: SubItem
  };
  const [partialSlots, childrenWithoutSlots] = useSlots.useSlots(props.children, {
    ...baseSlots,
    description: Description.Description
  });
  const slots = {
    description: undefined,
    ...partialSlots
  };
  const {
    container,
    afterSelect,
    selectionAttribute,
    defaultTrailingVisual
  } = React__default.default.useContext(ActionListContainerContext.ActionListContainerContext);

  // Be sure to avoid rendering the container unless there is a default
  const wrappedDefaultTrailingVisual = defaultTrailingVisual ? /*#__PURE__*/jsxRuntime.jsx(Visuals.TrailingVisual, {
    children: defaultTrailingVisual
  }) : null;
  const trailingVisual = (_slots$trailingVisual = slots.trailingVisual) !== null && _slots$trailingVisual !== void 0 ? _slots$trailingVisual : wrappedDefaultTrailingVisual;
  const {
    role: listRole,
    selectionVariant: listSelectionVariant
  } = React__default.default.useContext(shared.ListContext);
  const {
    selectionVariant: groupSelectionVariant
  } = React__default.default.useContext(Group.GroupContext);
  const inactive = Boolean(inactiveText);
  // TODO change `menuContext` check to ```listRole !== undefined && ['menu', 'listbox'].includes(listRole)```
  // once we have a better way to handle existing usage in dotcom that incorrectly use ActionList.TrailingAction
  const menuContext = container === 'ActionMenu' || container === 'SelectPanel';
  // TODO: when we change `menuContext` to check `listRole` instead of `container`
  const showInactiveIndicator = inactive && !(listRole !== undefined && ['menu', 'listbox'].includes(listRole));
  const onSelect = React__default.default.useCallback((event, afterSelect) => {
    if (typeof onSelectUser === 'function') onSelectUser(event);
    if (event.defaultPrevented) return;
    if (typeof afterSelect === 'function') afterSelect(event);
  }, [onSelectUser]);
  const selectionVariant = groupSelectionVariant ? groupSelectionVariant : listSelectionVariant;

  /** Infer item role based on the container */
  let inferredItemRole;
  if (container === 'ActionMenu') {
    if (selectionVariant === 'single') inferredItemRole = 'menuitemradio';else if (selectionVariant === 'multiple') inferredItemRole = 'menuitemcheckbox';else inferredItemRole = 'menuitem';
  } else if (listRole === 'listbox') {
    if (selectionVariant !== undefined && !role) inferredItemRole = 'option';
  }
  const itemRole = role || inferredItemRole;
  if (slots.trailingAction) {
    !!menuContext ? process.env.NODE_ENV !== "production" ? invariant.invariant(false, `ActionList.TrailingAction can not be used within a list with an ARIA role of "menu" or "listbox".`) : invariant.invariant(false) : void 0;
  }

  /** Infer the proper selection attribute based on the item's role */
  let inferredSelectionAttribute;
  if (itemRole === 'menuitemradio' || itemRole === 'menuitemcheckbox') inferredSelectionAttribute = 'aria-checked';else if (itemRole === 'option') inferredSelectionAttribute = 'aria-selected';
  const itemSelectionAttribute = selectionAttribute || inferredSelectionAttribute;
  // Ensures ActionList.Item retains list item semantics if a valid ARIA role is applied, or if item is inactive
  const listItemSemantics = role === 'option' || role === 'menuitem' || role === 'menuitemradio' || role === 'menuitemcheckbox';
  const listRoleTypes = ['listbox', 'menu', 'list'];
  const listSemantics = listRole && listRoleTypes.includes(listRole) || inactive || listItemSemantics;
  const buttonSemantics = !listSemantics && !_PrivateItemWrapper;
  const clickHandler = React__default.default.useCallback(event => {
    if (disabled || inactive || loading) return;
    onSelect(event, afterSelect);
  }, [onSelect, disabled, inactive, afterSelect, loading]);
  const keyPressHandler = React__default.default.useCallback(event => {
    if (disabled || inactive || loading) return;
    if ([' ', 'Enter'].includes(event.key)) {
      if (event.key === ' ') {
        event.preventDefault(); // prevent scrolling on Space
        // immediately reset defaultPrevented once its job is done
        // so as to not disturb the functions that use that event after this
        event.defaultPrevented = false;
      }
      onSelect(event, afterSelect);
    }
  }, [onSelect, disabled, loading, inactive, afterSelect]);
  const itemId = useId.useId(id);
  const labelId = `${itemId}--label`;
  const inlineDescriptionId = `${itemId}--inline-description`;
  const blockDescriptionId = `${itemId}--block-description`;
  const trailingVisualId = `${itemId}--trailing-visual`;
  const inactiveWarningId = inactive && !showInactiveIndicator ? `${itemId}--warning-message` : undefined;
  const DefaultItemWrapper = listSemantics ? DivItemContainerNoBox : ButtonItemContainerNoBox;
  const ItemWrapper = _PrivateItemWrapper || DefaultItemWrapper;

  // only apply aria-selected and aria-checked to selectable items
  const selectableRoles = ['menuitemradio', 'menuitemcheckbox', 'option'];
  const includeSelectionAttribute = itemSelectionAttribute && itemRole && selectableRoles.includes(itemRole);
  let focusable;
  if (showInactiveIndicator) {
    focusable = true;
  }

  // Extract the variant prop value from the description slot component
  const descriptionVariant = (_slots$description$pr = (_slots$description = slots.description) === null || _slots$description === void 0 ? void 0 : _slots$description.props.variant) !== null && _slots$description$pr !== void 0 ? _slots$description$pr : 'inline';
  const menuItemProps = {
    onClick: clickHandler,
    onKeyPress: !buttonSemantics ? keyPressHandler : undefined,
    'aria-disabled': disabled ? true : undefined,
    'data-inactive': inactive ? true : undefined,
    'data-loading': loading && !inactive ? true : undefined,
    tabIndex: focusable ? undefined : 0,
    'aria-labelledby': `${labelId} ${slots.trailingVisual ? trailingVisualId : ''} ${slots.description && descriptionVariant === 'inline' ? inlineDescriptionId : ''}`,
    'aria-describedby': [slots.description && descriptionVariant === 'block' ? blockDescriptionId : undefined, inactiveWarningId !== null && inactiveWarningId !== void 0 ? inactiveWarningId : undefined].filter(String).join(' ').trim() || undefined,
    ...(includeSelectionAttribute && {
      [itemSelectionAttribute]: selected
    }),
    role: itemRole,
    id: itemId
  };
  const containerProps = _PrivateItemWrapper ? {
    role: itemRole ? 'none' : undefined,
    ...props
  } :
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  listSemantics && {
    ...menuItemProps,
    ...props,
    ref: forwardedRef
  } || {};
  const wrapperProps = _PrivateItemWrapper ? menuItemProps : !listSemantics && {
    ...menuItemProps,
    ...props,
    ref: forwardedRef
  };
  return /*#__PURE__*/jsxRuntime.jsx(shared.ItemContext.Provider, {
    value: {
      variant,
      disabled,
      inactive: Boolean(inactiveText),
      inlineDescriptionId,
      blockDescriptionId,
      trailingVisualId
    },
    children: /*#__PURE__*/jsxRuntime.jsxs(BoxWithFallback.BoxWithFallback, {
      ...containerProps,
      as: "li",
      sx: sxProp,
      ref: listSemantics ? forwardedRef : null,
      "data-variant": variant === 'danger' ? variant : undefined,
      "data-active": active ? true : undefined,
      "data-inactive": inactiveText ? true : undefined,
      "data-has-subitem": slots.subItem ? true : undefined,
      className: clsx.clsx(ActionList_module.ActionListItem, className),
      children: [/*#__PURE__*/jsxRuntime.jsxs(ItemWrapper, {
        ...wrapperProps,
        className: ActionList_module.ActionListContent,
        children: [/*#__PURE__*/jsxRuntime.jsx("span", {
          className: ActionList_module.Spacer
        }), /*#__PURE__*/jsxRuntime.jsx(Selection.Selection, {
          selected: selected,
          className: ActionList_module.LeadingAction
        }), /*#__PURE__*/jsxRuntime.jsx(Visuals.VisualOrIndicator, {
          inactiveText: showInactiveIndicator ? inactiveText : undefined,
          itemHasLeadingVisual: Boolean(slots.leadingVisual),
          labelId: labelId,
          loading: loading,
          position: "leading",
          children: slots.leadingVisual
        }), /*#__PURE__*/jsxRuntime.jsxs("span", {
          className: ActionList_module.ActionListSubContent,
          "data-component": "ActionList.Item--DividerContainer",
          children: [/*#__PURE__*/jsxRuntime.jsxs(ConditionalWrapper.ConditionalWrapper, {
            if: !!slots.description,
            className: ActionList_module.ItemDescriptionWrap,
            "data-description-variant": descriptionVariant,
            children: [/*#__PURE__*/jsxRuntime.jsxs("span", {
              id: labelId,
              className: ActionList_module.ItemLabel,
              children: [childrenWithoutSlots, loading === true && !inactive && /*#__PURE__*/jsxRuntime.jsx(_VisuallyHidden, {
                children: "Loading"
              })]
            }), slots.description]
          }), /*#__PURE__*/jsxRuntime.jsx(Visuals.VisualOrIndicator, {
            inactiveText: showInactiveIndicator ? inactiveText : undefined,
            itemHasLeadingVisual: Boolean(slots.leadingVisual),
            labelId: labelId,
            loading: loading,
            position: "trailing",
            children: trailingVisual
          }),
          // If the item is inactive, but it's not in an overlay (e.g. ActionMenu, SelectPanel),
          // render the inactive warning message directly in the item.
          !showInactiveIndicator ? /*#__PURE__*/jsxRuntime.jsx("span", {
            className: ActionList_module.InactiveWarning,
            id: inactiveWarningId,
            children: inactiveText
          }) : null]
        })]
      }), !inactive && !loading && !menuContext && Boolean(slots.trailingAction) && slots.trailingAction, slots.subItem]
    })
  });
});
Item.displayName = 'ActionList.Item';

exports.Item = Item;
exports.SubItem = SubItem;
