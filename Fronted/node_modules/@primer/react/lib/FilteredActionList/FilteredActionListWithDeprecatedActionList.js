'use strict';

var behaviors = require('@primer/behaviors');
var React = require('react');
var styled = require('styled-components');
var constants = require('../constants.js');
var index$1 = require('../deprecated/ActionList/index.js');
var useFocusZone = require('../hooks/useFocusZone.js');
var useId = require('../hooks/useId.js');
var useProvidedRefOrCreate = require('../hooks/useProvidedRefOrCreate.js');
var useProvidedStateOrCreate = require('../hooks/useProvidedStateOrCreate.js');
var useScrollFlash = require('../hooks/useScrollFlash.js');
var FilteredActionListLoaders = require('./FilteredActionListLoaders.js');
var liveRegionElement = require('@primer/live-region-element');
var index = require('../node_modules/@github/mini-throttle/dist/index.js');
var jsxRuntime = require('react/jsx-runtime');
var Box = require('../Box/Box.js');
var TextInput = require('../TextInput/TextInput.js');
var VisuallyHidden = require('../VisuallyHidden/VisuallyHidden.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var styled__default = /*#__PURE__*/_interopDefault(styled);

const menuScrollMargins = {
  startMargin: 0,
  endMargin: 8
};
const StyledHeader = styled__default.default.div.withConfig({
  displayName: "FilteredActionListWithDeprecatedActionList__StyledHeader",
  componentId: "sc-o1spcd-0"
})(["box-shadow:0 1px 0 ", ";z-index:1;"], constants.get('colors.border.default'));
const getItemWithActiveDescendant = (listRef, items) => {
  const listElement = listRef.current;
  const activeItemElement = listElement === null || listElement === void 0 ? void 0 : listElement.querySelector('[data-is-active-descendant]');
  if (!listElement || !(activeItemElement !== null && activeItemElement !== void 0 && activeItemElement.textContent)) return;
  const optionElements = listElement.querySelectorAll('[role="option"]');
  const index = Array.from(optionElements).indexOf(activeItemElement);
  const activeItem = items[index];
  const text = activeItem.text;
  const selected = activeItemElement.getAttribute('aria-selected') === 'true';
  return {
    index,
    text,
    selected
  };
};
async function announceText(text) {
  const liveRegion = document.querySelector('live-region');
  liveRegion === null || liveRegion === void 0 ? void 0 : liveRegion.clear(); // clear previous announcements

  await liveRegionElement.announce(text, {
    delayMs: 500,
    from: liveRegion ? liveRegion : undefined // announce will create a liveRegion if it doesn't find one
  });
}
const announceItemsChanged = index.debounce(async (items, listContainerRef) => {
  const liveRegion = document.querySelector('live-region');
  liveRegion === null || liveRegion === void 0 ? void 0 : liveRegion.clear(); // clear previous announcements

  // give @primer/behaviors a moment to update active-descendant
  await new Promise(resolve => window.requestAnimationFrame(resolve));
  const activeItem = getItemWithActiveDescendant(listContainerRef, items);
  if (!activeItem) return;
  const {
    index,
    text,
    selected
  } = activeItem;
  const announcementText = ['List updated', `Focused item: ${text}`, `${selected ? 'selected' : 'not selected'}`, `${index + 1} of ${items.length}`].join(', ');
  await liveRegionElement.announce(announcementText, {
    delayMs: 500,
    from: liveRegion ? liveRegion : undefined // announce will create a liveRegion if it doesn't find one
  });
}, 250);
async function announceFilterFocused() {
  await announceText('Focus on filter text box and list of items');
}
function FilteredActionList({
  loading = false,
  loadingType = FilteredActionListLoaders.FilteredActionListLoadingTypes.bodySpinner,
  placeholderText,
  filterValue: externalFilterValue,
  onFilterChange,
  onListContainerRefChanged,
  onInputRefChanged,
  items,
  textInputProps,
  inputRef: providedInputRef,
  sx,
  className,
  announcementsEnabled = false,
  ...listProps
}) {
  const [filterValue, setInternalFilterValue] = useProvidedStateOrCreate.useProvidedStateOrCreate(externalFilterValue, undefined, '');
  const onInputChange = React.useCallback(e => {
    const value = e.target.value;
    onFilterChange(value, e);
    setInternalFilterValue(value);
  }, [onFilterChange, setInternalFilterValue]);
  const scrollContainerRef = React.useRef(null);
  const [listContainerElement, setListContainerElement] = React.useState(null);
  const inputRef = useProvidedRefOrCreate.useProvidedRefOrCreate(providedInputRef);
  const [needItemsChangedAnnouncement, setNeedItemsChangedAnnouncement] = React.useState(false);
  const activeDescendantRef = React.useRef();
  const listId = useId.useId();
  const inputDescriptionTextId = useId.useId();
  const onInputKeyPress = React.useCallback(event => {
    if (event.key === 'Enter' && activeDescendantRef.current) {
      event.preventDefault();
      event.nativeEvent.stopImmediatePropagation();

      // Forward Enter key press to active descendant so that item gets activated
      const activeDescendantEvent = new KeyboardEvent(event.type, event.nativeEvent);
      activeDescendantRef.current.dispatchEvent(activeDescendantEvent);
    }
  }, [activeDescendantRef]);
  const listContainerRefCallback = React.useCallback(node => {
    setListContainerElement(node);
    onListContainerRefChanged === null || onListContainerRefChanged === void 0 ? void 0 : onListContainerRefChanged(node);
    if (needItemsChangedAnnouncement) {
      announceItemsChanged(items, {
        current: node
      });
      setNeedItemsChangedAnnouncement(false);
    }
  }, [items, needItemsChangedAnnouncement, onListContainerRefChanged]);
  React.useEffect(() => {
    onInputRefChanged === null || onInputRefChanged === void 0 ? void 0 : onInputRefChanged(inputRef);
  }, [inputRef, onInputRefChanged]);
  useFocusZone.useFocusZone({
    containerRef: {
      current: listContainerElement
    },
    focusOutBehavior: 'wrap',
    focusableElementFilter: element => {
      return !(element instanceof HTMLInputElement);
    },
    activeDescendantFocus: inputRef,
    onActiveDescendantChanged: (current, previous, directlyActivated) => {
      activeDescendantRef.current = current;
      if (current && scrollContainerRef.current && directlyActivated) {
        behaviors.scrollIntoView(current, scrollContainerRef.current, menuScrollMargins);
      }
    }
  }, [
  // List container isn't in the DOM while loading.  Need to re-bind focus zone when it changes.
  listContainerElement]);
  React.useEffect(() => {
    // if items changed, we want to instantly move active descendant into view
    if (activeDescendantRef.current && scrollContainerRef.current) {
      behaviors.scrollIntoView(activeDescendantRef.current, scrollContainerRef.current, {
        ...menuScrollMargins,
        behavior: 'auto'
      });
    }
    if (announcementsEnabled) {
      if (listContainerElement) {
        announceItemsChanged(items, {
          current: listContainerElement
        });
      } else {
        setNeedItemsChangedAnnouncement(true);
      }
    }
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [items]);
  useScrollFlash(scrollContainerRef);
  return /*#__PURE__*/jsxRuntime.jsxs(Box, {
    display: "flex",
    flexDirection: "column",
    overflow: "hidden",
    flexGrow: 1,
    sx: sx,
    className: className,
    "data-testid": "filtered-action-list",
    children: [/*#__PURE__*/jsxRuntime.jsx(StyledHeader, {
      children: /*#__PURE__*/jsxRuntime.jsx(TextInput, {
        ref: inputRef,
        block: true,
        width: "auto",
        color: "fg.default",
        value: filterValue,
        onChange: onInputChange,
        onKeyPress: onInputKeyPress,
        placeholder: placeholderText,
        "aria-label": placeholderText,
        "aria-controls": listId,
        "aria-describedby": inputDescriptionTextId,
        loaderPosition: 'leading',
        loading: loading && !loadingType.appearsInBody,
        onFocus: announcementsEnabled ? announceFilterFocused : undefined,
        ...textInputProps
      })
    }), /*#__PURE__*/jsxRuntime.jsx(VisuallyHidden.VisuallyHidden, {
      id: inputDescriptionTextId,
      children: "Items will be filtered as you type"
    }), /*#__PURE__*/jsxRuntime.jsx(Box, {
      ref: scrollContainerRef,
      overflow: "auto",
      flexGrow: 1,
      children: loading && scrollContainerRef.current && loadingType.appearsInBody ? /*#__PURE__*/jsxRuntime.jsx(FilteredActionListLoaders.FilteredActionListBodyLoader, {
        loadingType: loadingType,
        height: scrollContainerRef.current.clientHeight
      }) : /*#__PURE__*/jsxRuntime.jsx(index$1.ActionList, {
        ref: listContainerRefCallback,
        items: items,
        ...listProps,
        role: "listbox",
        id: listId
      })
    })]
  });
}
FilteredActionList.displayName = "FilteredActionList";
FilteredActionList.displayName = 'FilteredActionList';

exports.FilteredActionList = FilteredActionList;
