export declare class Hsluv {
    private static hexChars;
    private static refY;
    private static refU;
    private static refV;
    private static kappa;
    private static epsilon;
    private static m_r0;
    private static m_r1;
    private static m_r2;
    private static m_g0;
    private static m_g1;
    private static m_g2;
    private static m_b0;
    private static m_b1;
    private static m_b2;
    hex: string;
    rgb_r: number;
    rgb_g: number;
    rgb_b: number;
    xyz_x: number;
    xyz_y: number;
    xyz_z: number;
    luv_l: number;
    luv_u: number;
    luv_v: number;
    lch_l: number;
    lch_c: number;
    lch_h: number;
    hsluv_h: number;
    hsluv_s: number;
    hsluv_l: number;
    hpluv_h: number;
    hpluv_p: number;
    hpluv_l: number;
    r0s: number;
    r0i: number;
    r1s: number;
    r1i: number;
    g0s: number;
    g0i: number;
    g1s: number;
    g1i: number;
    b0s: number;
    b0i: number;
    b1s: number;
    b1i: number;
    private static fromLinear;
    private static toLinear;
    private static yToL;
    private static lToY;
    private static rgbChannelToHex;
    private static hexToRgbChannel;
    private static distanceFromOriginAngle;
    private static distanceFromOrigin;
    private static min6;
    rgbToHex(): void;
    hexToRgb(): void;
    xyzToRgb(): void;
    rgbToXyz(): void;
    xyzToLuv(): void;
    luvToXyz(): void;
    luvToLch(): void;
    lchToLuv(): void;
    calculateBoundingLines(l: number): void;
    calcMaxChromaHpluv(): number;
    calcMaxChromaHsluv(h: number): number;
    hsluvToLch(): void;
    lchToHsluv(): void;
    hpluvToLch(): void;
    lchToHpluv(): void;
    hsluvToRgb(): void;
    hpluvToRgb(): void;
    hsluvToHex(): void;
    hpluvToHex(): void;
    rgbToHsluv(): void;
    rgbToHpluv(): void;
    hexToHsluv(): void;
    hexToHpluv(): void;
}
