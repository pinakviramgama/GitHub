'use strict';

var behaviors = require('@primer/behaviors');
var React = require('react');
var styled = require('styled-components');
var constants = require('../constants.js');
var index = require('../ActionList/index.js');
var useFocusZone = require('../hooks/useFocusZone.js');
var useId = require('../hooks/useId.js');
var useProvidedRefOrCreate = require('../hooks/useProvidedRefOrCreate.js');
var useProvidedStateOrCreate = require('../hooks/useProvidedStateOrCreate.js');
var useScrollFlash = require('../hooks/useScrollFlash.js');
var FilteredActionListLoaders = require('./FilteredActionListLoaders.js');
var FilteredActionList_module = require('./FilteredActionList.module.css.js');
var reactIs = require('react-is');
var useAnnouncements = require('./useAnnouncements.js');
var clsx = require('clsx');
var jsxRuntime = require('react/jsx-runtime');
var Box = require('../Box/Box.js');
var TextInput = require('../TextInput/TextInput.js');
var VisuallyHidden = require('../VisuallyHidden/VisuallyHidden.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var styled__default = /*#__PURE__*/_interopDefault(styled);

const menuScrollMargins = {
  startMargin: 0,
  endMargin: 8
};
const StyledHeader = styled__default.default.div.withConfig({
  displayName: "FilteredActionListWithModernActionList__StyledHeader",
  componentId: "sc-1d2kw5v-0"
})(["box-shadow:0 1px 0 ", ";z-index:1;"], constants.get('colors.border.default'));
function FilteredActionList({
  loading = false,
  placeholderText,
  filterValue: externalFilterValue,
  loadingType = FilteredActionListLoaders.FilteredActionListLoadingTypes.bodySpinner,
  onFilterChange,
  onListContainerRefChanged,
  onInputRefChanged,
  items,
  textInputProps,
  inputRef: providedInputRef,
  sx,
  groupMetadata,
  showItemDividers,
  message,
  className,
  announcementsEnabled = true,
  fullScreenOnNarrow,
  ...listProps
}) {
  const [filterValue, setInternalFilterValue] = useProvidedStateOrCreate.useProvidedStateOrCreate(externalFilterValue, undefined, '');
  const onInputChange = React.useCallback(e => {
    const value = e.target.value;
    onFilterChange(value, e);
    setInternalFilterValue(value);
  }, [onFilterChange, setInternalFilterValue]);
  const scrollContainerRef = React.useRef(null);
  const inputRef = useProvidedRefOrCreate.useProvidedRefOrCreate(providedInputRef);
  const [listContainerElement, setListContainerElement] = React.useState(null);
  const activeDescendantRef = React.useRef();
  const listId = useId.useId();
  const inputDescriptionTextId = useId.useId();
  const onInputKeyPress = React.useCallback(event => {
    if (event.key === 'Enter' && activeDescendantRef.current) {
      event.preventDefault();
      event.nativeEvent.stopImmediatePropagation();

      // Forward Enter key press to active descendant so that item gets activated
      const activeDescendantEvent = new KeyboardEvent(event.type, event.nativeEvent);
      activeDescendantRef.current.dispatchEvent(activeDescendantEvent);
    }
  }, [activeDescendantRef]);
  const listContainerRefCallback = React.useCallback(node => {
    setListContainerElement(node);
    onListContainerRefChanged === null || onListContainerRefChanged === void 0 ? void 0 : onListContainerRefChanged(node);
  }, [onListContainerRefChanged]);
  React.useEffect(() => {
    onInputRefChanged === null || onInputRefChanged === void 0 ? void 0 : onInputRefChanged(inputRef);
  }, [inputRef, onInputRefChanged]);
  useFocusZone.useFocusZone({
    containerRef: {
      current: listContainerElement
    },
    bindKeys: behaviors.FocusKeys.ArrowVertical | behaviors.FocusKeys.PageUpDown,
    focusOutBehavior: 'wrap',
    focusableElementFilter: element => {
      return !(element instanceof HTMLInputElement);
    },
    activeDescendantFocus: inputRef,
    onActiveDescendantChanged: (current, previous, directlyActivated) => {
      activeDescendantRef.current = current;
      if (current && scrollContainerRef.current && directlyActivated) {
        behaviors.scrollIntoView(current, scrollContainerRef.current, menuScrollMargins);
      }
    }
  }, [
  // List container isn't in the DOM while loading.  Need to re-bind focus zone when it changes.
  listContainerElement]);
  React.useEffect(() => {
    // if items changed, we want to instantly move active descendant into view
    if (activeDescendantRef.current && scrollContainerRef.current) {
      behaviors.scrollIntoView(activeDescendantRef.current, scrollContainerRef.current, {
        ...menuScrollMargins,
        behavior: 'auto'
      });
    }
  }, [items]);
  useAnnouncements.useAnnouncements(items, {
    current: listContainerElement
  }, inputRef, announcementsEnabled, loading);
  useScrollFlash(scrollContainerRef);
  function getItemListForEachGroup(groupId) {
    const itemsInGroup = [];
    for (const item of items) {
      // Look up the group associated with the current item.
      if (item.groupId === groupId) {
        itemsInGroup.push(item);
      }
    }
    return itemsInGroup;
  }
  function getBodyContent() {
    if (loading && scrollContainerRef.current && loadingType.appearsInBody) {
      return /*#__PURE__*/jsxRuntime.jsx(FilteredActionListLoaders.FilteredActionListBodyLoader, {
        loadingType: loadingType,
        height: scrollContainerRef.current.clientHeight
      });
    }
    if (message) {
      return message;
    }
    return /*#__PURE__*/jsxRuntime.jsx(index.ActionList, {
      ref: listContainerRefCallback,
      showDividers: showItemDividers,
      ...listProps,
      role: "listbox",
      id: listId,
      sx: {
        flexGrow: 1
      },
      children: groupMetadata !== null && groupMetadata !== void 0 && groupMetadata.length ? groupMetadata.map((group, index$1) => {
        var _group$header, _group$header2;
        return /*#__PURE__*/jsxRuntime.jsxs(index.ActionList.Group, {
          children: [/*#__PURE__*/jsxRuntime.jsx(index.ActionList.GroupHeading, {
            variant: (_group$header = group.header) !== null && _group$header !== void 0 && _group$header.variant ? group.header.variant : undefined,
            children: (_group$header2 = group.header) !== null && _group$header2 !== void 0 && _group$header2.title ? group.header.title : `Group ${group.groupId}`
          }), getItemListForEachGroup(group.groupId).map(({
            key: itemKey,
            ...item
          }, index) => {
            var _ref, _item$id;
            const key = (_ref = itemKey !== null && itemKey !== void 0 ? itemKey : (_item$id = item.id) === null || _item$id === void 0 ? void 0 : _item$id.toString()) !== null && _ref !== void 0 ? _ref : index.toString();
            return /*#__PURE__*/jsxRuntime.jsx(MappedActionListItem, {
              ...item,
              renderItem: listProps.renderItem
            }, key);
          })]
        }, index$1);
      }) : items.map(({
        key: itemKey,
        ...item
      }, index) => {
        var _ref2, _item$id2;
        const key = (_ref2 = itemKey !== null && itemKey !== void 0 ? itemKey : (_item$id2 = item.id) === null || _item$id2 === void 0 ? void 0 : _item$id2.toString()) !== null && _ref2 !== void 0 ? _ref2 : index.toString();
        return /*#__PURE__*/jsxRuntime.jsx(MappedActionListItem, {
          ...item,
          renderItem: listProps.renderItem
        }, key);
      })
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs(Box, {
    display: "flex",
    flexDirection: "column",
    overflow: "hidden",
    sx: sx,
    className: className,
    "data-testid": "filtered-action-list",
    children: [/*#__PURE__*/jsxRuntime.jsx(StyledHeader, {
      children: /*#__PURE__*/jsxRuntime.jsx(TextInput, {
        ref: inputRef,
        block: true,
        width: "auto",
        color: "fg.default",
        value: filterValue,
        onChange: onInputChange,
        onKeyPress: onInputKeyPress,
        placeholder: placeholderText,
        role: "combobox",
        "aria-expanded": "true",
        "aria-autocomplete": "list",
        "aria-controls": listId,
        "aria-label": placeholderText,
        "aria-describedby": inputDescriptionTextId,
        loaderPosition: 'leading',
        loading: loading && !loadingType.appearsInBody,
        className: clsx.clsx(textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.className, fullScreenOnNarrow && FilteredActionList_module.FullScreenTextInput),
        ...textInputProps
      })
    }), /*#__PURE__*/jsxRuntime.jsx(VisuallyHidden.VisuallyHidden, {
      id: inputDescriptionTextId,
      children: "Items will be filtered as you type"
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      ref: scrollContainerRef,
      className: FilteredActionList_module.Container,
      children: getBodyContent()
    })]
  });
}
FilteredActionList.displayName = "FilteredActionList";
function MappedActionListItem(item) {
  // keep backward compatibility for renderItem
  // escape hatch for custom Item rendering
  if (typeof item.renderItem === 'function') return item.renderItem(item);
  const {
    id,
    description,
    descriptionVariant,
    text,
    trailingVisual: TrailingVisual,
    leadingVisual: LeadingVisual,
    trailingText,
    trailingIcon: TrailingIcon,
    onAction,
    children,
    ...rest
  } = item;
  return /*#__PURE__*/jsxRuntime.jsxs(index.ActionList.Item, {
    role: "option"
    // @ts-ignore - for now
    ,
    onSelect: e => {
      if (typeof onAction === 'function') onAction(item, e);
    },
    "data-id": id,
    ...rest,
    children: [LeadingVisual ? /*#__PURE__*/jsxRuntime.jsx(index.ActionList.LeadingVisual, {
      children: /*#__PURE__*/jsxRuntime.jsx(LeadingVisual, {})
    }) : null, children, text, description ? /*#__PURE__*/jsxRuntime.jsx(index.ActionList.Description, {
      variant: descriptionVariant,
      children: description
    }) : null, TrailingVisual ? /*#__PURE__*/jsxRuntime.jsx(index.ActionList.TrailingVisual, {
      children: typeof TrailingVisual !== 'string' && reactIs.isValidElementType(TrailingVisual) ? /*#__PURE__*/jsxRuntime.jsx(TrailingVisual, {}) : TrailingVisual
    }) : TrailingIcon || trailingText ? /*#__PURE__*/jsxRuntime.jsxs(index.ActionList.TrailingVisual, {
      children: [trailingText, TrailingIcon && /*#__PURE__*/jsxRuntime.jsx(TrailingIcon, {})]
    }) : null]
  });
}
MappedActionListItem.displayName = "MappedActionListItem";
FilteredActionList.displayName = 'FilteredActionList';

exports.FilteredActionList = FilteredActionList;
