import React, { useRef, useState, useCallback, useEffect } from 'react';
import { IconButton } from '../Button/IconButton.js';
import { ButtonComponent } from '../Button/Button.js';
import { useFocusTrap } from '../hooks/useFocusTrap.js';
import { XIcon } from '@primer/octicons-react';
import { useFocusZone } from '../hooks/useFocusZone.js';
import { FocusKeys } from '@primer/behaviors';
import { Portal } from '../Portal/Portal.js';
import { useRefObjectAsForwardedRef } from '../hooks/useRefObjectAsForwardedRef.js';
import { useId } from '../hooks/useId.js';
import classes from './Dialog.module.css.js';
import { clsx } from 'clsx';
import { BoxWithFallback } from '../internal/components/BoxWithFallback.js';
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import { useOnEscapePress } from '../hooks/useOnEscapePress.js';
import { ScrollableRegion } from '../ScrollableRegion/ScrollableRegion.js';
import { useProvidedRefOrCreate } from '../hooks/useProvidedRefOrCreate.js';
import Box from '../Box/Box.js';

const DefaultHeader = ({
  dialogLabelId,
  title,
  subtitle,
  dialogDescriptionId,
  onClose
}) => {
  const onCloseClick = useCallback(() => {
    onClose('close-button');
  }, [onClose]);
  return /*#__PURE__*/jsx(Dialog.Header, {
    children: /*#__PURE__*/jsxs(Box, {
      display: "flex",
      children: [/*#__PURE__*/jsxs(Box, {
        display: "flex",
        px: 2,
        py: "6px",
        flexDirection: "column",
        flexGrow: 1,
        children: [/*#__PURE__*/jsx(Dialog.Title, {
          id: dialogLabelId,
          children: title !== null && title !== void 0 ? title : 'Dialog'
        }), subtitle && /*#__PURE__*/jsx(Dialog.Subtitle, {
          id: dialogDescriptionId,
          children: subtitle
        })]
      }), /*#__PURE__*/jsx(Dialog.CloseButton, {
        onClose: onCloseClick
      })]
    })
  });
};
DefaultHeader.displayName = "DefaultHeader";
const DefaultBody = ({
  children
}) => {
  return /*#__PURE__*/jsx(Dialog.Body, {
    children: children
  });
};
DefaultBody.displayName = "DefaultBody";
const DefaultFooter = ({
  footerButtons
}) => {
  const {
    containerRef: footerRef
  } = useFocusZone({
    bindKeys: FocusKeys.ArrowHorizontal | FocusKeys.Tab,
    focusInStrategy: 'closest'
  });
  return footerButtons ? /*#__PURE__*/jsx(Dialog.Footer, {
    ref: footerRef,
    children: /*#__PURE__*/jsx(Dialog.Buttons, {
      buttons: footerButtons
    })
  }) : null;
};
const defaultPosition = {
  narrow: 'center',
  regular: 'center'
};
const defaultFooterButtons = [];
const _Dialog = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  const {
    title = 'Dialog',
    subtitle = '',
    renderHeader,
    renderBody,
    renderFooter,
    onClose,
    role = 'dialog',
    width = 'xlarge',
    height = 'auto',
    footerButtons = defaultFooterButtons,
    position = defaultPosition,
    returnFocusRef,
    initialFocusRef,
    sx,
    className
  } = props;
  const dialogLabelId = useId();
  const dialogDescriptionId = useId();
  const autoFocusedFooterButtonRef = useRef(null);
  for (const footerButton of footerButtons) {
    if (footerButton.autoFocus) {
      // eslint-disable-next-line react-compiler/react-compiler
      footerButton.ref = autoFocusedFooterButtonRef;
    }
  }
  const [lastMouseDownIsBackdrop, setLastMouseDownIsBackdrop] = useState(false);
  const defaultedProps = {
    ...props,
    title,
    subtitle,
    role,
    dialogLabelId,
    dialogDescriptionId
  };
  const onBackdropClick = useCallback(e => {
    if (e.target === e.currentTarget && lastMouseDownIsBackdrop) {
      onClose('escape');
    }
  }, [onClose, lastMouseDownIsBackdrop]);
  const dialogRef = useRef(null);
  useRefObjectAsForwardedRef(forwardedRef, dialogRef);
  const backdropRef = useRef(null);
  useFocusTrap({
    containerRef: dialogRef,
    initialFocusRef: initialFocusRef !== null && initialFocusRef !== void 0 ? initialFocusRef : autoFocusedFooterButtonRef,
    restoreFocusOnCleanUp: returnFocusRef !== null && returnFocusRef !== void 0 && returnFocusRef.current ? false : true,
    returnFocusRef
  });
  useOnEscapePress(event => {
    onClose('escape');
    event.preventDefault();
  }, [onClose]);
  React.useEffect(() => {
    const bodyOverflowStyle = document.body.style.overflow || '';
    // If the body is already set to overflow: hidden, it likely means
    // that there is already a modal open. In that case, we should bail
    // so we don't re-enable scroll after the second dialog is closed.
    if (bodyOverflowStyle === 'hidden') {
      return;
    }
    document.body.style.overflow = 'hidden';
    return () => {
      document.body.style.overflow = bodyOverflowStyle;
    };
  }, []);
  const header = (renderHeader !== null && renderHeader !== void 0 ? renderHeader : DefaultHeader)(defaultedProps);
  const body = (renderBody !== null && renderBody !== void 0 ? renderBody : DefaultBody)(defaultedProps);
  const footer = (renderFooter !== null && renderFooter !== void 0 ? renderFooter : DefaultFooter)(defaultedProps);
  const positionDataAttributes = typeof position === 'string' ? {
    'data-position-regular': position
  } : Object.fromEntries(Object.entries(position).map(([key, value]) => {
    return [`data-position-${key}`, value];
  }));
  return /*#__PURE__*/jsx(Fragment, {
    children: /*#__PURE__*/jsx(Portal, {
      children: /*#__PURE__*/jsx(BoxWithFallback, {
        as: "div",
        ref: backdropRef,
        className: classes.Backdrop,
        ...positionDataAttributes,
        onClick: onBackdropClick,
        onMouseDown: e => {
          setLastMouseDownIsBackdrop(e.target === e.currentTarget);
        },
        children: /*#__PURE__*/jsxs(BoxWithFallback, {
          as: "div",
          ref: dialogRef,
          role: role,
          "aria-labelledby": dialogLabelId,
          "aria-describedby": dialogDescriptionId,
          "aria-modal": true,
          ...positionDataAttributes,
          "data-width": width,
          "data-height": height,
          sx: sx,
          className: clsx(className, classes.Dialog),
          children: [header, /*#__PURE__*/jsx(ScrollableRegion, {
            "aria-labelledby": dialogLabelId,
            className: classes.DialogOverflowWrapper,
            children: body
          }), footer]
        })
      })
    })
  });
});
_Dialog.displayName = 'Dialog';
const Header = /*#__PURE__*/React.forwardRef(function Header({
  className,
  ...rest
}, forwardRef) {
  return /*#__PURE__*/jsx(BoxWithFallback, {
    as: "div",
    ref: forwardRef,
    className: clsx(className, classes.Header),
    ...rest
  });
});
Header.displayName = 'Dialog.Header';
const Title = /*#__PURE__*/React.forwardRef(function Title({
  className,
  ...rest
}, forwardRef) {
  return /*#__PURE__*/jsx(BoxWithFallback, {
    as: "h1",
    ref: forwardRef,
    className: clsx(className, classes.Title),
    ...rest
  });
});
Title.displayName = 'Dialog.Title';
const Subtitle = /*#__PURE__*/React.forwardRef(function Subtitle({
  className,
  ...rest
}, forwardRef) {
  return /*#__PURE__*/jsx(BoxWithFallback, {
    as: "h2",
    ref: forwardRef,
    className: clsx(className, classes.Subtitle),
    ...rest
  });
});
Subtitle.displayName = 'Dialog.Subtitle';
const Body = /*#__PURE__*/React.forwardRef(function Body({
  className,
  ...rest
}, forwardRef) {
  return /*#__PURE__*/jsx(BoxWithFallback, {
    as: "div",
    ref: forwardRef,
    className: clsx(className, classes.Body),
    ...rest
  });
});
Body.displayName = 'Dialog.Body';
const Footer = /*#__PURE__*/React.forwardRef(function Footer({
  className,
  ...rest
}, forwardRef) {
  return /*#__PURE__*/jsx(BoxWithFallback, {
    as: "div",
    ref: forwardRef,
    className: clsx(className, classes.Footer),
    ...rest
  });
});
Footer.displayName = 'Dialog.Footer';
const Buttons = ({
  buttons
}) => {
  var _buttons$find;
  const autoFocusRef = useProvidedRefOrCreate((_buttons$find = buttons.find(button => button.autoFocus)) === null || _buttons$find === void 0 ? void 0 : _buttons$find.ref);
  let autoFocusCount = 0;
  const [hasRendered, setHasRendered] = useState(0);
  useEffect(() => {
    // hack to work around dialogs originating from other focus traps.
    if (hasRendered === 1) {
      var _autoFocusRef$current;
      (_autoFocusRef$current = autoFocusRef.current) === null || _autoFocusRef$current === void 0 ? void 0 : _autoFocusRef$current.focus();
    } else {
      setHasRendered(hasRendered + 1);
    }
  }, [autoFocusRef, hasRendered]);
  return /*#__PURE__*/jsx(Fragment, {
    children: buttons.map((dialogButtonProps, index) => {
      const {
        content,
        buttonType = 'default',
        autoFocus = false,
        ...buttonProps
      } = dialogButtonProps;
      return /*#__PURE__*/jsx(ButtonComponent, {
        ...buttonProps,
        // 'normal' value is equivalent to 'default', this is used for backwards compatibility
        variant: buttonType === 'normal' ? 'default' : buttonType,
        ref: autoFocus && autoFocusCount === 0 ? (autoFocusCount++, autoFocusRef) : null,
        children: content
      }, index);
    })
  });
};
const CloseButton = ({
  onClose
}) => {
  return /*#__PURE__*/jsx(IconButton, {
    icon: XIcon,
    "aria-label": "Close",
    onClick: onClose,
    variant: "invisible"
  });
};
CloseButton.displayName = "CloseButton";
/**
 * A dialog is a type of overlay that can be used for confirming actions, asking
 * for disambiguation, and presenting small forms. They generally allow the user
 * to focus on a quick task without having to navigate to a different page.
 *
 * Dialogs appear in the page after a direct user interaction. Don't show dialogs
 * on page load or as system alerts.
 *
 * Dialogs appear centered in the page, with a visible backdrop that dims the rest
 * of the window for focus.
 *
 * All dialogs have a title and a close button.
 *
 * Dialogs are modal. Dialogs can be dismissed by clicking on the close button,
 * pressing the escape key, or by interacting with another button in the dialog.
 * To avoid losing information and missing important messages, clicking outside
 * of the dialog will not close it.
 *
 * The sub components provided (e.g. Header, Title, etc.) are available for custom
 * renderers only. They are not intended to be used otherwise.
 */
const Dialog = Object.assign(_Dialog, {
  Header,
  Title,
  Subtitle,
  Body,
  Footer,
  Buttons,
  CloseButton
});

export { Dialog };
