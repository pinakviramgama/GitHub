import React, { useRef } from 'react';
import { clsx } from 'clsx';
import { useId } from '../hooks/useId.js';
import { useRefObjectAsForwardedRef } from '../hooks/useRefObjectAsForwardedRef.js';
import { isResponsiveValue, useResponsiveValue } from '../hooks/useResponsiveValue.js';
import { useSlots } from '../hooks/useSlots.js';
import { canUseDOM } from '../utils/environment.js';
import { useOverflow } from '../hooks/useOverflow.js';
import { warning } from '../utils/warning.js';
import classes from './PageLayout.module.css.js';
import { BoxWithFallback } from '../internal/components/BoxWithFallback.js';
import { defaultSxProp } from '../utils/defaultSxProp.js';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import Box from '../Box/Box.js';

const PageLayoutContext = /*#__PURE__*/React.createContext({
  padding: 'normal',
  rowGap: 'normal',
  columnGap: 'normal',
  paneRef: {
    current: null
  }
});

// TODO: refs
const Root = ({
  containerWidth = 'xlarge',
  padding = 'normal',
  rowGap = 'normal',
  columnGap = 'normal',
  children,
  sx = defaultSxProp,
  className,
  style,
  _slotsConfig: slotsConfig
}) => {
  const paneRef = useRef(null);
  const [slots, rest] = useSlots(children, slotsConfig !== null && slotsConfig !== void 0 ? slotsConfig : {
    header: Header,
    footer: Footer
  });
  const memoizedContextValue = React.useMemo(() => {
    return {
      padding,
      rowGap,
      columnGap,
      paneRef
    };
  }, [padding, rowGap, columnGap, paneRef]);
  return /*#__PURE__*/jsx(PageLayoutContext.Provider, {
    value: memoizedContextValue,
    children: /*#__PURE__*/jsx(BoxWithFallback, {
      style: {
        '--spacing': `var(--spacing-${padding})`,
        ...style
      },
      sx: sx,
      className: clsx(classes.PageLayoutRoot, className),
      children: /*#__PURE__*/jsxs("div", {
        className: classes.PageLayoutWrapper,
        "data-width": containerWidth,
        children: [slots.header, /*#__PURE__*/jsx("div", {
          className: clsx(classes.PageLayoutContent),
          children: rest
        }), slots.footer]
      })
    })
  });
};
Root.displayName = "Root";
Root.displayName = 'PageLayout';

// ----------------------------------------------------------------------------
// Divider (internal)

const HorizontalDivider = ({
  variant = 'none',
  sx = defaultSxProp,
  className,
  position,
  style
}) => {
  const {
    padding
  } = React.useContext(PageLayoutContext);
  const responsiveVariant = useResponsiveValue(variant, 'none');
  return /*#__PURE__*/jsx(BoxWithFallback, {
    sx: sx,
    className: clsx(classes.HorizontalDivider, className),
    "data-variant": responsiveVariant,
    "data-position": position,
    style: {
      '--spacing-divider': `var(--spacing-${padding})`,
      ...style
    }
  });
};
HorizontalDivider.displayName = "HorizontalDivider";
const VerticalDivider = ({
  variant = 'none',
  draggable = false,
  onDragStart,
  onDrag,
  onDragEnd,
  onDoubleClick,
  position,
  className,
  style,
  sx = defaultSxProp
}) => {
  const [isDragging, setIsDragging] = React.useState(false);
  const [isKeyboardDrag, setIsKeyboardDrag] = React.useState(false);
  const responsiveVariant = useResponsiveValue(variant, 'none');
  const stableOnDrag = React.useRef(onDrag);
  const stableOnDragEnd = React.useRef(onDragEnd);
  const {
    paneRef
  } = React.useContext(PageLayoutContext);
  const [minWidth, setMinWidth] = React.useState(0);
  const [maxWidth, setMaxWidth] = React.useState(0);
  const [currentWidth, setCurrentWidth] = React.useState(0);
  React.useEffect(() => {
    if (paneRef.current !== null) {
      const paneStyles = getComputedStyle(paneRef.current);
      const maxPaneWidthDiffPixels = paneStyles.getPropertyValue('--pane-max-width-diff');
      const minWidthPixels = paneStyles.getPropertyValue('--pane-min-width');
      const paneWidth = paneRef.current.getBoundingClientRect().width;
      const maxPaneWidthDiff = Number(maxPaneWidthDiffPixels.split('px')[0]);
      const minPaneWidth = Number(minWidthPixels.split('px')[0]);
      const viewportWidth = window.innerWidth;
      const maxPaneWidth = viewportWidth > maxPaneWidthDiff ? viewportWidth - maxPaneWidthDiff : viewportWidth;
      setMinWidth(minPaneWidth);
      setMaxWidth(maxPaneWidth);
      setCurrentWidth(paneWidth || 0);
    }
  }, [paneRef, isKeyboardDrag, isDragging]);
  React.useEffect(() => {
    stableOnDrag.current = onDrag;
  }, [onDrag]);
  React.useEffect(() => {
    stableOnDragEnd.current = onDragEnd;
  }, [onDragEnd]);
  React.useEffect(() => {
    function handleDrag(event) {
      var _stableOnDrag$current;
      (_stableOnDrag$current = stableOnDrag.current) === null || _stableOnDrag$current === void 0 ? void 0 : _stableOnDrag$current.call(stableOnDrag, event.movementX, false);
      event.preventDefault();
    }
    function handleDragEnd(event) {
      var _stableOnDragEnd$curr;
      setIsDragging(false);
      (_stableOnDragEnd$curr = stableOnDragEnd.current) === null || _stableOnDragEnd$curr === void 0 ? void 0 : _stableOnDragEnd$curr.call(stableOnDragEnd);
      event.preventDefault();
    }
    function handleKeyDrag(event) {
      var _stableOnDrag$current2;
      let delta = 0;
      // https://github.com/github/accessibility/issues/5101#issuecomment-1822870655
      if ((event.key === 'ArrowLeft' || event.key === 'ArrowDown') && currentWidth > minWidth) {
        delta = -3;
      } else if ((event.key === 'ArrowRight' || event.key === 'ArrowUp') && currentWidth < maxWidth) {
        delta = 3;
      } else {
        return;
      }
      setCurrentWidth(currentWidth + delta);
      (_stableOnDrag$current2 = stableOnDrag.current) === null || _stableOnDrag$current2 === void 0 ? void 0 : _stableOnDrag$current2.call(stableOnDrag, delta, true);
      event.preventDefault();
    }
    function handleKeyDragEnd(event) {
      var _stableOnDragEnd$curr2;
      setIsKeyboardDrag(false);
      (_stableOnDragEnd$curr2 = stableOnDragEnd.current) === null || _stableOnDragEnd$curr2 === void 0 ? void 0 : _stableOnDragEnd$curr2.call(stableOnDragEnd);
      event.preventDefault();
    }
    // TODO: Support touch events
    if (isDragging || isKeyboardDrag) {
      window.addEventListener('mousemove', handleDrag);
      window.addEventListener('keydown', handleKeyDrag);
      window.addEventListener('mouseup', handleDragEnd);
      window.addEventListener('keyup', handleKeyDragEnd);
      const body = document.body;
      body === null || body === void 0 ? void 0 : body.setAttribute('data-page-layout-dragging', 'true');
    } else {
      window.removeEventListener('mousemove', handleDrag);
      window.removeEventListener('mouseup', handleDragEnd);
      window.removeEventListener('keydown', handleKeyDrag);
      window.removeEventListener('keyup', handleKeyDragEnd);
      const body = document.body;
      body === null || body === void 0 ? void 0 : body.removeAttribute('data-page-layout-dragging');
    }
    return () => {
      window.removeEventListener('mousemove', handleDrag);
      window.removeEventListener('mouseup', handleDragEnd);
      window.removeEventListener('keydown', handleKeyDrag);
      window.removeEventListener('keyup', handleKeyDragEnd);
      const body = document.body;
      body === null || body === void 0 ? void 0 : body.removeAttribute('data-page-layout-dragging');
    };
  }, [isDragging, isKeyboardDrag, currentWidth, minWidth, maxWidth]);
  return /*#__PURE__*/jsx(BoxWithFallback, {
    sx: sx,
    className: clsx(classes.VerticalDivider, className),
    "data-variant": responsiveVariant,
    "data-position": position,
    style: style,
    children: draggable ?
    /*#__PURE__*/
    // Drag handle
    jsx(Fragment, {
      children: /*#__PURE__*/jsx(Box, {
        sx: {
          position: 'absolute',
          inset: '0 -2px',
          cursor: 'col-resize',
          bg: isDragging || isKeyboardDrag ? 'accent.fg' : 'transparent',
          transitionDelay: '0.1s',
          '&:hover': {
            bg: isDragging || isKeyboardDrag ? 'accent.fg' : 'neutral.muted'
          }
        },
        role: "slider",
        "aria-label": "Draggable pane splitter",
        "aria-valuemin": minWidth,
        "aria-valuemax": maxWidth,
        "aria-valuenow": currentWidth,
        "aria-valuetext": `Pane width ${currentWidth} pixels`,
        tabIndex: 0,
        onMouseDown: event => {
          if (event.button === 0) {
            setIsDragging(true);
            onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart();
          }
        },
        onKeyDown: event => {
          if (event.key === 'ArrowLeft' || event.key === 'ArrowRight' || event.key === 'ArrowUp' || event.key === 'ArrowDown') {
            setIsKeyboardDrag(true);
            onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart();
          }
        },
        onDoubleClick: onDoubleClick
      })
    }) : null
  });
};
VerticalDivider.displayName = "VerticalDivider"; // ----------------------------------------------------------------------------
// PageLayout.Header
const Header = ({
  'aria-label': label,
  'aria-labelledby': labelledBy,
  padding = 'none',
  divider = 'none',
  dividerWhenNarrow = 'inherit',
  hidden = false,
  children,
  style,
  sx = defaultSxProp,
  className
}) => {
  // Combine divider and dividerWhenNarrow for backwards compatibility
  const dividerProp = !isResponsiveValue(divider) && dividerWhenNarrow !== 'inherit' ? {
    regular: divider,
    narrow: dividerWhenNarrow
  } : divider;
  const dividerVariant = useResponsiveValue(dividerProp, 'none');
  const isHidden = useResponsiveValue(hidden, false);
  const {
    rowGap
  } = React.useContext(PageLayoutContext);
  return /*#__PURE__*/jsxs(BoxWithFallback, {
    as: "header",
    "aria-label": label,
    "aria-labelledby": labelledBy,
    hidden: isHidden,
    sx: sx,
    className: clsx(classes.Header, className),
    style: {
      '--spacing': `var(--spacing-${rowGap})`,
      ...style
    },
    children: [/*#__PURE__*/jsx("div", {
      className: classes.HeaderContent,
      style: {
        '--spacing': `var(--spacing-${padding})`
      },
      children: children
    }), /*#__PURE__*/jsx(HorizontalDivider, {
      variant: dividerVariant,
      className: classes.HeaderHorizontalDivider,
      style: {
        '--spacing': `var(--spacing-${rowGap})`
      }
    })]
  });
};
Header.displayName = "Header";
Header.displayName = 'PageLayout.Header';
const Content = ({
  as = 'main',
  'aria-label': label,
  'aria-labelledby': labelledBy,
  width = 'full',
  padding = 'none',
  hidden = false,
  children,
  sx = defaultSxProp,
  className,
  style
}) => {
  const isHidden = useResponsiveValue(hidden, false);
  return /*#__PURE__*/jsx(BoxWithFallback, {
    as: as,
    "aria-label": label,
    "aria-labelledby": labelledBy,
    style: style,
    sx: sx,
    className: clsx(classes.ContentWrapper, className),
    "data-is-hidden": isHidden,
    children: /*#__PURE__*/jsx("div", {
      className: classes.Content,
      "data-width": width,
      style: {
        '--spacing': `var(--spacing-${padding})`
      },
      children: children
    })
  });
};
Content.displayName = "Content";
Content.displayName = 'PageLayout.Content';

// ----------------------------------------------------------------------------
// PageLayout.Pane

const isCustomWidthOptions = width => {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return width.default !== undefined;
};
const isPaneWidth = width => {
  return ['small', 'medium', 'large'].includes(width);
};
const defaultPaneWidth = {
  small: 256,
  medium: 296,
  large: 320
};
const overflowProps = {
  tabIndex: 0,
  role: 'region'
};
const Pane = /*#__PURE__*/React.forwardRef(({
  'aria-label': label,
  'aria-labelledby': labelledBy,
  position: responsivePosition = 'end',
  positionWhenNarrow = 'inherit',
  width = 'medium',
  minWidth = 256,
  padding = 'none',
  resizable = false,
  widthStorageKey = 'paneWidth',
  divider: responsiveDivider = 'none',
  dividerWhenNarrow = 'inherit',
  sticky = false,
  offsetHeader = 0,
  hidden: responsiveHidden = false,
  children,
  id,
  sx = defaultSxProp,
  className,
  style
}, forwardRef) => {
  // Combine position and positionWhenNarrow for backwards compatibility
  const positionProp = !isResponsiveValue(responsivePosition) && positionWhenNarrow !== 'inherit' ? {
    regular: responsivePosition,
    narrow: positionWhenNarrow
  } : responsivePosition;
  const position = useResponsiveValue(positionProp, 'end');

  // Combine divider and dividerWhenNarrow for backwards compatibility
  const dividerProp = !isResponsiveValue(responsiveDivider) && dividerWhenNarrow !== 'inherit' ? {
    regular: responsiveDivider,
    narrow: dividerWhenNarrow
  } : responsiveDivider;
  const dividerVariant = useResponsiveValue(dividerProp, 'none');
  const isHidden = useResponsiveValue(responsiveHidden, false);
  const {
    rowGap,
    columnGap,
    paneRef
  } = React.useContext(PageLayoutContext);
  const getDefaultPaneWidth = width => {
    if (isPaneWidth(width)) {
      return defaultPaneWidth[width];
    } else if (isCustomWidthOptions(width)) {
      return Number(width.default.split('px')[0]);
    }
    return 0;
  };
  const [paneWidth, setPaneWidth] = React.useState(() => {
    if (!canUseDOM) {
      return getDefaultPaneWidth(width);
    }
    let storedWidth;
    try {
      storedWidth = localStorage.getItem(widthStorageKey);
    } catch (_error) {
      storedWidth = null;
    }
    return storedWidth && !isNaN(Number(storedWidth)) ? Number(storedWidth) : getDefaultPaneWidth(width);
  });
  const updatePaneWidth = width => {
    setPaneWidth(width);
    try {
      localStorage.setItem(widthStorageKey, width.toString());
    } catch (_error) {
      // Ignore errors
    }
  };
  useRefObjectAsForwardedRef(forwardRef, paneRef);
  const hasOverflow = useOverflow(paneRef);
  const paneId = useId(id);
  const labelProp = {};
  if (hasOverflow) {
    process.env.NODE_ENV !== "production" ? warning(label === undefined && labelledBy === undefined, 'The <PageLayout.Pane> has overflow and `aria-label` or `aria-labelledby` has not been set. ' + 'Please provide `aria-label` or `aria-labelledby` to <PageLayout.Pane> in order to label this ' + 'region.') : void 0;
    if (labelledBy) {
      labelProp['aria-labelledby'] = labelledBy;
    } else if (label) {
      labelProp['aria-label'] = label;
    }
  }
  return /*#__PURE__*/jsxs(BoxWithFallback, {
    sx: sx,
    className: clsx(classes.PaneWrapper, className),
    style: {
      '--offset-header': typeof offsetHeader === 'number' ? `${offsetHeader}px` : offsetHeader,
      '--spacing-row': `var(--spacing-${rowGap})`,
      '--spacing-column': `var(--spacing-${columnGap})`,
      ...style
    },
    "data-is-hidden": isHidden,
    "data-position": position,
    "data-sticky": sticky || undefined,
    children: [/*#__PURE__*/jsx(HorizontalDivider, {
      variant: {
        narrow: dividerVariant,
        regular: 'none'
      },
      className: classes.PaneHorizontalDivider,
      style: {
        '--spacing': `var(--spacing-${rowGap})`
      },
      position: position
    }), /*#__PURE__*/jsx("div", {
      ref: paneRef,
      ...(hasOverflow ? overflowProps : {}),
      ...labelProp,
      ...(id && {
        id: paneId
      }),
      className: classes.Pane,
      "data-resizable": resizable || undefined,
      style: {
        '--spacing': `var(--spacing-${padding})`,
        '--pane-min-width': isCustomWidthOptions(width) ? width.min : `${minWidth}px`,
        '--pane-max-width': isCustomWidthOptions(width) ? width.max : `calc(100vw - var(--pane-max-width-diff))`,
        '--pane-width-custom': isCustomWidthOptions(width) ? width.default : undefined,
        '--pane-width-size': `var(--pane-width-${isPaneWidth(width) ? width : 'custom'})`,
        '--pane-width': `${paneWidth}px`
      },
      children: children
    }), /*#__PURE__*/jsx(VerticalDivider, {
      variant: {
        narrow: 'none',
        // If pane is resizable, always show a vertical divider on regular viewports
        regular: resizable ? 'line' : dividerVariant
      }
      // If pane is resizable, the divider should be draggable
      ,
      draggable: resizable,
      onDrag: (delta, isKeyboard = false) => {
        // Get the number of pixels the divider was dragged
        let deltaWithDirection;
        if (isKeyboard) {
          deltaWithDirection = delta;
        } else {
          deltaWithDirection = position === 'end' ? -delta : delta;
        }
        updatePaneWidth(paneWidth + deltaWithDirection);
      }
      // Ensure `paneWidth` state and actual pane width are in sync when the drag ends
      ,
      onDragEnd: () => {
        var _paneRef$current;
        const paneRect = (_paneRef$current = paneRef.current) === null || _paneRef$current === void 0 ? void 0 : _paneRef$current.getBoundingClientRect();
        if (!paneRect) return;
        updatePaneWidth(paneRect.width);
      },
      position: position
      // Reset pane width on double click
      ,
      onDoubleClick: () => updatePaneWidth(getDefaultPaneWidth(width)),
      className: classes.PaneVerticalDivider,
      style: {
        '--spacing': `var(--spacing-${columnGap})`
      }
    })]
  });
});
Pane.displayName = 'PageLayout.Pane';

// ----------------------------------------------------------------------------
// PageLayout.Footer

const Footer = ({
  'aria-label': label,
  'aria-labelledby': labelledBy,
  padding = 'none',
  divider = 'none',
  dividerWhenNarrow = 'inherit',
  hidden = false,
  children,
  sx = defaultSxProp,
  className,
  style
}) => {
  // Combine divider and dividerWhenNarrow for backwards compatibility
  const dividerProp = !isResponsiveValue(divider) && dividerWhenNarrow !== 'inherit' ? {
    regular: divider,
    narrow: dividerWhenNarrow
  } : divider;
  const dividerVariant = useResponsiveValue(dividerProp, 'none');
  const isHidden = useResponsiveValue(hidden, false);
  const {
    rowGap
  } = React.useContext(PageLayoutContext);
  return /*#__PURE__*/jsxs(BoxWithFallback, {
    as: "footer",
    "aria-label": label,
    "aria-labelledby": labelledBy,
    hidden: isHidden,
    className: clsx(classes.FooterWrapper, className),
    sx: sx,
    style: {
      '--spacing': `var(--spacing-${rowGap})`,
      ...style
    },
    children: [/*#__PURE__*/jsx(HorizontalDivider, {
      className: classes.FooterHorizontalDivider,
      style: {
        '--spacing': `var(--spacing-${rowGap})`
      },
      variant: dividerVariant
    }), /*#__PURE__*/jsx("div", {
      className: classes.FooterContent,
      style: {
        '--spacing': `var(--spacing-${padding})`
      },
      children: children
    })]
  });
};
Footer.displayName = "Footer";
Footer.displayName = 'PageLayout.Footer';

// ----------------------------------------------------------------------------
// Export

const PageLayout = Object.assign(Root, {
  Header,
  Content,
  Pane,
  Footer
});

export { PageLayout };
