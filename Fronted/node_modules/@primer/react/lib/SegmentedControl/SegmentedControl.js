'use strict';

var React = require('react');
var SegmentedControlButton = require('./SegmentedControlButton.js');
var SegmentedControlIconButton = require('./SegmentedControlIconButton.js');
var index = require('../ActionList/index.js');
var ThemeProvider = require('../ThemeProvider.js');
var useResponsiveValue = require('../hooks/useResponsiveValue.js');
var defaultSxProp = require('../utils/defaultSxProp.js');
var reactIs = require('react-is');
var SegmentedControl_module = require('./SegmentedControl.module.css.js');
var clsx = require('clsx');
var BoxWithFallback = require('../internal/components/BoxWithFallback.js');
var jsxRuntime = require('react/jsx-runtime');
var ActionMenu = require('../ActionMenu/ActionMenu.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

const Root = ({
  'aria-label': ariaLabel,
  'aria-labelledby': ariaLabelledby,
  children,
  fullWidth,
  onChange,
  size,
  sx: sxProp = defaultSxProp.defaultSxProp,
  variant = 'default',
  className,
  ...rest
}) => {
  const segmentedControlContainerRef = React.useRef(null);
  const {
    theme
  } = ThemeProvider.useTheme();
  const isUncontrolled = onChange === undefined || React__default.default.Children.toArray(children).some(child => /*#__PURE__*/React__default.default.isValidElement(child) && child.props.defaultSelected !== undefined);
  const responsiveVariant = useResponsiveValue.useResponsiveValue(variant, 'default');
  const isFullWidth = useResponsiveValue.useResponsiveValue(fullWidth, false);
  const selectedSegments = React__default.default.Children.toArray(children).map(child => /*#__PURE__*/React__default.default.isValidElement(child) && (child.props.defaultSelected || child.props.selected));
  const hasSelectedButton = selectedSegments.some(isSelected => isSelected);
  const selectedIndexExternal = hasSelectedButton ? selectedSegments.indexOf(true) : 0;
  const [selectedIndexInternalState, setSelectedIndexInternalState] = React.useState(selectedIndexExternal);
  const selectedIndex = isUncontrolled ? selectedIndexInternalState : selectedIndexExternal;
  const selectedChild = /*#__PURE__*/React__default.default.isValidElement(React__default.default.Children.toArray(children)[selectedIndex]) ? React__default.default.Children.toArray(children)[selectedIndex] : undefined;
  const getChildIcon = childArg => {
    if (/*#__PURE__*/React__default.default.isValidElement(childArg) && childArg.type === SegmentedControlButton && childArg.props.leadingIcon) {
      if (reactIs.isElement(childArg.props.leadingIcon)) {
        return childArg.props.leadingIcon;
      } else {
        const LeadingIcon = childArg.props.leadingIcon;
        return /*#__PURE__*/jsxRuntime.jsx(LeadingIcon, {});
      }
    }
    if (/*#__PURE__*/React__default.default.isValidElement(childArg) && childArg.type === SegmentedControlIconButton.SegmentedControlIconButton) {
      if (reactIs.isElement(childArg.props.icon)) {
        childArg.props.icon;
      } else {
        const Icon = childArg.props.icon;
        return /*#__PURE__*/jsxRuntime.jsx(Icon, {});
      }
    }
    return null;
  };
  const getChildText = childArg => {
    if (/*#__PURE__*/React__default.default.isValidElement(childArg) && childArg.type === SegmentedControlButton) {
      return childArg.props.children;
    }
    return /*#__PURE__*/React__default.default.isValidElement(childArg) ? childArg.props['aria-label'] : null;
  };
  if (!ariaLabel && !ariaLabelledby) {
    // eslint-disable-next-line no-console
    console.warn('Use the `aria-label` or `aria-labelledby` prop to provide an accessible label for assistive technologies');
  }
  return responsiveVariant === 'dropdown' ?
  /*#__PURE__*/
  // Render the 'dropdown' variant of the SegmentedControlButton or SegmentedControlIconButton
  jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: /*#__PURE__*/jsxRuntime.jsxs(ActionMenu.ActionMenu, {
      children: [/*#__PURE__*/jsxRuntime.jsx(ActionMenu.ActionMenu.Button, {
        "aria-label": ariaLabel && `${getChildText(selectedChild)}, ${ariaLabel}`,
        leadingVisual: getChildIcon(selectedChild),
        children: getChildText(selectedChild)
      }), /*#__PURE__*/jsxRuntime.jsx(ActionMenu.ActionMenu.Overlay, {
        "aria-labelledby": ariaLabelledby,
        children: /*#__PURE__*/jsxRuntime.jsx(index.ActionList, {
          selectionVariant: "single",
          children: React__default.default.Children.map(children, (child, index$1) => {
            const ChildIcon = getChildIcon(child);
            // Not a valid child element - skip rendering
            if (! /*#__PURE__*/React__default.default.isValidElement(child)) {
              return null;
            }
            return /*#__PURE__*/jsxRuntime.jsxs(index.ActionList.Item, {
              selected: index$1 === selectedIndex,
              onSelect: event => {
                isUncontrolled && setSelectedIndexInternalState(index$1);
                onChange && onChange(index$1);
                child.props.onClick && child.props.onClick(event);
              },
              children: [ChildIcon, " ", getChildText(child)]
            }, `segmented-control-action-btn-${index$1}`);
          })
        })
      })]
    })
  }) :
  /*#__PURE__*/
  // Render a segmented control
  jsxRuntime.jsx(BoxWithFallback.BoxWithFallback, {
    as: "ul",
    sx: sxProp,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledby,
    ref: segmentedControlContainerRef,
    className: clsx.clsx(SegmentedControl_module.SegmentedControl, className),
    "data-full-width": isFullWidth || undefined,
    "data-size": size,
    ...rest,
    children: React__default.default.Children.map(children, (child, index) => {
      // Not a valid child element - skip rendering child
      if (! /*#__PURE__*/React__default.default.isValidElement(child)) {
        return null;
      }
      const sharedChildProps = {
        onClick: onChange ? event => {
          onChange(index);
          isUncontrolled && setSelectedIndexInternalState(index);
          child.props.onClick && child.props.onClick(event);
        } : event => {
          child.props.onClick && child.props.onClick(event);
          isUncontrolled && setSelectedIndexInternalState(index);
        },
        selected: index === selectedIndex,
        style: {
          '--separator-color': index === selectedIndex || index === selectedIndex - 1 ? 'transparent' : theme === null || theme === void 0 ? void 0 : theme.colors.border.default,
          ...child.props.style
        },
        sx: child.props.sx
      };

      // Render the 'hideLabels' variant of the SegmentedControlButton
      if (responsiveVariant === 'hideLabels' && /*#__PURE__*/React__default.default.isValidElement(child) && child.type === SegmentedControlButton) {
        const {
          'aria-label': childAriaLabel,
          leadingIcon,
          children: childPropsChildren,
          ...restChildProps
        } = child.props;
        const {
          sx: sharedSxProp,
          ...restSharedChildProps
        } = sharedChildProps;
        if (!leadingIcon) {
          // eslint-disable-next-line no-console
          console.warn('A `leadingIcon` prop is required when hiding visible labels');
        } else {
          return /*#__PURE__*/jsxRuntime.jsx(SegmentedControlIconButton.SegmentedControlIconButton, {
            "aria-label": childAriaLabel || childPropsChildren,
            icon: leadingIcon,
            sx: {
              ...sharedSxProp,
              // setting width here avoids having to pass `isFullWidth` directly to child components
              width: !isFullWidth ? '32px' : '100%' // TODO: use primitive `control.medium.size` when it is available instead of '32px'
            },
            ...restSharedChildProps,
            ...restChildProps
          });
        }
      }

      // Render the children as-is and add the shared child props
      return /*#__PURE__*/React__default.default.cloneElement(child, sharedChildProps);
    })
  });
};
Root.displayName = 'SegmentedControl';
const SegmentedControl = Object.assign(Root, {
  Button: SegmentedControlButton,
  IconButton: SegmentedControlIconButton.SegmentedControlIconButton
});

exports.SegmentedControl = SegmentedControl;
