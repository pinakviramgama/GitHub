import React from 'react';
import styled from 'styled-components';
import { XIcon } from '@primer/octicons-react';
import { getFocusableChild } from '@primer/behaviors/utils';
import { get } from '../constants.js';
import VisuallyHidden from '../_VisuallyHidden.js';
import { IconButton } from '../Button/IconButton.js';
import { ButtonComponent } from '../Button/Button.js';
import { useTheme } from '../ThemeProvider.js';
import sx from '../sx.js';
import { jsxs, jsx } from 'react/jsx-runtime';
import { AnchoredOverlay } from '../AnchoredOverlay/AnchoredOverlay.js';
import Box from '../Box/Box.js';

const StyledLabelGroupContainer = styled.div.withConfig({
  displayName: "LabelGroup__StyledLabelGroupContainer",
  componentId: "sc-6tqg8q-0"
})(["display:flex;flex-wrap:nowrap;gap:", ";line-height:1;max-width:100%;overflow:hidden;&[data-overflow='inline']{flex-wrap:wrap;}&[data-list]{padding-inline-start:0;margin-block-start:0;margin-block-end:0;list-style-type:none;}", ";"], get('space.1'), sx);
const ItemWrapper = styled.div.withConfig({
  displayName: "LabelGroup__ItemWrapper",
  componentId: "sc-6tqg8q-1"
})(["display:flex;align-items:center;min-height:28px;&.ItemWrapper--hidden{order:9999;pointer-events:none;visibility:hidden;}"]);

// Calculates the width of the overlay to cover the labels/tokens and the expand button.
const getOverlayWidth = (buttonClientRect, containerRef, overlayPaddingPx) => {
  var _containerRef$current;
  return overlayPaddingPx + buttonClientRect.right - (((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.getBoundingClientRect().left) || 0);
};
const InlineToggle = ({
  collapseButtonRef,
  collapseInlineExpandedChildren,
  expandButtonRef,
  hiddenItemIds,
  isOverflowShown,
  showAllTokensInline
}) => isOverflowShown ? /*#__PURE__*/jsx(ButtonComponent, {
  ref: collapseButtonRef,
  onClick: collapseInlineExpandedChildren,
  size: "small",
  variant: "invisible",
  children: "Show less"
}) : hiddenItemIds.length ? /*#__PURE__*/jsxs(ButtonComponent, {
  ref: expandButtonRef,
  variant: "invisible",
  size: "small",
  onClick: showAllTokensInline,
  children: [/*#__PURE__*/jsxs(VisuallyHidden, {
    children: ["Show +", hiddenItemIds.length, " more"]
  }), /*#__PURE__*/jsxs("span", {
    "aria-hidden": "true",
    children: ["+", hiddenItemIds.length]
  })]
}) : null;
const OverlayToggle = ({
  children,
  closeOverflowOverlay,
  expandButtonRef,
  hiddenItemIds,
  isOverflowShown,
  openOverflowOverlay,
  overlayPaddingPx,
  overlayWidth
}) => hiddenItemIds.length ? /*#__PURE__*/jsx(AnchoredOverlay, {
  open: isOverflowShown,
  onOpen: openOverflowOverlay,
  onClose: closeOverflowOverlay,
  width: "auto",
  height: "auto",
  align: "start",
  side: "inside-right"
  // expandButtonRef satisfies React.RefObject<HTMLButtonElement> because we manually set `.current` in the `useCallback` above
  ,
  anchorRef: expandButtonRef,
  anchorOffset: overlayPaddingPx * -1,
  alignmentOffset: overlayPaddingPx * -1,
  renderAnchor: props => /*#__PURE__*/jsxs(ButtonComponent, {
    variant: "invisible",
    size: "small",
    ...props,
    ref: expandButtonRef,
    children: [/*#__PURE__*/jsxs(VisuallyHidden, {
      children: ["Show +", hiddenItemIds.length, " more"]
    }), /*#__PURE__*/jsxs("span", {
      "aria-hidden": "true",
      children: ["+", hiddenItemIds.length]
    })]
  }),
  focusZoneSettings: {
    disabled: true
  },
  children: /*#__PURE__*/jsxs(Box, {
    alignItems: "flex-start",
    display: "flex",
    width: overlayWidth,
    padding: `${overlayPaddingPx}px`,
    children: [/*#__PURE__*/jsx(Box, {
      display: "flex",
      flexWrap: "wrap",
      sx: {
        gap: 1
      },
      children: children
    }), /*#__PURE__*/jsx(IconButton, {
      onClick: closeOverflowOverlay,
      icon: XIcon,
      "aria-label": "Close",
      variant: "invisible",
      sx: {
        flexShrink: 0
      }
    })]
  })
}) : null;

// TODO: reduce re-renders
const LabelGroup = ({
  children,
  visibleChildCount,
  overflowStyle = 'overlay',
  sx: sxProp,
  as = 'ul',
  className
}) => {
  const containerRef = React.useRef(null);
  const collapseButtonRef = React.useRef(null);
  const firstHiddenIndexRef = React.useRef(undefined);
  const [visibilityMap, setVisibilityMap] = React.useState({});
  const [isOverflowShown, setIsOverflowShown] = React.useState(false);
  const [buttonClientRect, setButtonClientRect] = React.useState({
    width: 0,
    right: 0,
    height: 0,
    x: 0,
    y: 0,
    top: 0,
    left: 0,
    bottom: 0,
    toJSON: () => undefined
  });
  const {
    theme
  } = useTheme();
  const overlayPaddingPx = parseInt(get('space.2')(theme), 10);
  const hiddenItemIds = Object.keys(visibilityMap).filter(key => !visibilityMap[key]);

  // `overlayWidth` is only needed when we render an overlay
  // if we don't use an overlay, we can skip the width calculation
  // and save on reflows caused by measuring DOM nodes.
  const overlayWidth = hiddenItemIds.length && overflowStyle === 'overlay' ? getOverlayWidth(buttonClientRect, containerRef, overlayPaddingPx) : undefined;
  const expandButtonRef = React.useCallback(node => {
    if (node !== null) {
      const nodeClientRect = node.getBoundingClientRect();
      if (nodeClientRect.width !== buttonClientRect.width || nodeClientRect.right !== buttonClientRect.right) {
        setButtonClientRect(nodeClientRect);
      }

      // @ts-ignore you can set `.current` on ref objects or ref callbacks in React
      expandButtonRef.current = node;
    }
  }, [buttonClientRect]);

  // Sets the visibility map to hide children after the given index.
  const hideChildrenAfterIndex = React.useCallback(truncateAfter => {
    var _containerRef$current2;
    const containerChildren = ((_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children) || [];
    const updatedEntries = {};
    for (const child of containerChildren) {
      const targetId = child.getAttribute('data-index');
      if (targetId) {
        updatedEntries[targetId] = parseInt(targetId, 10) < truncateAfter;
      }
    }
    setVisibilityMap(updatedEntries);
  }, []);
  const openOverflowOverlay = React.useCallback(() => setIsOverflowShown(true), [setIsOverflowShown]);
  const closeOverflowOverlay = React.useCallback(() => {
    setIsOverflowShown(false);
  }, [setIsOverflowShown]);
  const collapseInlineExpandedChildren = React.useCallback(() => {
    setIsOverflowShown(false);
    if (visibleChildCount && typeof visibleChildCount === 'number') {
      hideChildrenAfterIndex(visibleChildCount);
    }

    // We need to manually re-focus the collapse button if we're not showing the full
    // list in an overlay.
    // TODO: get rid of this hack
    setTimeout(() => {
      var _expandButtonRef$curr;
      // @ts-ignore you can set `.current` on ref objects or ref callbacks in React
      (_expandButtonRef$curr = expandButtonRef.current) === null || _expandButtonRef$curr === void 0 ? void 0 : _expandButtonRef$curr.focus();
    }, 10);
  }, [expandButtonRef, hideChildrenAfterIndex, visibleChildCount]);
  const showAllTokensInline = React.useCallback(() => {
    setVisibilityMap({});
    setIsOverflowShown(true);
  }, [setVisibilityMap, setIsOverflowShown]);
  React.useEffect(() => {
    // If we're not truncating, we don't need to run this useEffect.
    if (!visibleChildCount || isOverflowShown) {
      return;
    }
    if (visibleChildCount === 'auto') {
      // Instatiates the IntersectionObserver to track when children fit in the container.
      const observer = new IntersectionObserver(entries => {
        const updatedEntries = {};
        for (const entry of entries) {
          // Checks which children are intersecting the root container
          const targetId = entry.target.getAttribute('data-index');
          if (targetId) {
            updatedEntries[targetId] = entry.isIntersecting;
          }
        }

        // Updates the visibility map based on the intersection results.
        setVisibilityMap(prev => ({
          ...prev,
          ...updatedEntries
        }));
      }, {
        root: containerRef.current,
        rootMargin: `0px -${buttonClientRect.width}px 0px 0px`,
        threshold: 1
      });
      for (const item of ((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []) {
        var _containerRef$current3;
        if (item.getAttribute('data-index')) {
          observer.observe(item);
        }
      }
      return () => observer.disconnect();
    }
    // We're not auto truncating, so we need to hide children after the given `visibleChildCount`.
    else {
      hideChildrenAfterIndex(visibleChildCount);
    }
  }, [buttonClientRect, visibleChildCount, hideChildrenAfterIndex, isOverflowShown]);

  // Updates the index of the first hidden child.
  // We need to keep track of this so we can focus the first hidden child when the overflow is shown inline.
  React.useEffect(() => {
    // If we're using an overlay, we don't need to keep track of the first hidden index.
    if (overflowStyle === 'overlay') {
      return;
    }
    if (hiddenItemIds.length) {
      firstHiddenIndexRef.current = parseInt(hiddenItemIds[0], 10);
    }
  }, [hiddenItemIds, overflowStyle, isOverflowShown]);

  // Updates the index of the first hidden child.
  // We need to keep track of this so we can focus the first hidden child when the overflow is shown inline.
  React.useEffect(() => {
    // If we're using an overlay, we don't need to focus the first child that was previously hidden.
    if (overflowStyle === 'overlay') {
      return;
    }
    const firstHiddenChildDOM = document.querySelector(`[data-index="${firstHiddenIndexRef.current}"]`);
    const focusableChild = firstHiddenChildDOM ? getFocusableChild(firstHiddenChildDOM) : null;
    if (isOverflowShown) {
      // If the first hidden child is focusable, focus it.
      // Otherwise, focus the collapse button.
      if (focusableChild) {
        focusableChild.focus();
      } else {
        var _collapseButtonRef$cu;
        (_collapseButtonRef$cu = collapseButtonRef.current) === null || _collapseButtonRef$cu === void 0 ? void 0 : _collapseButtonRef$cu.focus();
      }
    }
  }, [overflowStyle, isOverflowShown]);
  const isList = as === 'ul' || as === 'ol';
  const ToggleWrapper = isList ? 'li' : React.Fragment;

  // If truncation is enabled, we need to render based on truncation logic.
  return visibleChildCount ? /*#__PURE__*/jsxs(StyledLabelGroupContainer, {
    ref: containerRef,
    "data-overflow": overflowStyle === 'inline' && isOverflowShown ? 'inline' : undefined,
    "data-list": isList || undefined,
    sx: sxProp,
    className: className,
    as: as,
    children: [React.Children.map(children, (child, index) => /*#__PURE__*/jsx(ItemWrapper
    // data-index is used as an identifier we can use in the IntersectionObserver
    , {
      "data-index": index,
      className: hiddenItemIds.includes(index.toString()) ? 'ItemWrapper--hidden' : undefined,
      as: isList ? 'li' : 'span',
      children: child
    }, index)), /*#__PURE__*/jsx(ToggleWrapper, {
      children: overflowStyle === 'inline' ? /*#__PURE__*/jsx(InlineToggle, {
        collapseButtonRef: collapseButtonRef,
        collapseInlineExpandedChildren: collapseInlineExpandedChildren,
        expandButtonRef: expandButtonRef,
        hiddenItemIds: hiddenItemIds,
        isOverflowShown: isOverflowShown,
        showAllTokensInline: showAllTokensInline,
        totalLength: React.Children.toArray(children).length
      }) : /*#__PURE__*/jsx(OverlayToggle, {
        closeOverflowOverlay: closeOverflowOverlay,
        expandButtonRef: expandButtonRef,
        hiddenItemIds: hiddenItemIds,
        isOverflowShown: isOverflowShown,
        openOverflowOverlay: openOverflowOverlay,
        overlayPaddingPx: overlayPaddingPx,
        overlayWidth: overlayWidth,
        totalLength: React.Children.toArray(children).length,
        children: children
      })
    })]
  }) : /*#__PURE__*/jsx(StyledLabelGroupContainer, {
    "data-overflow": "inline",
    "data-list": isList || undefined,
    sx: sxProp,
    as: as,
    className: className,
    children: isList ? React.Children.map(children, (child, index) => {
      return /*#__PURE__*/jsx("li", {
        children: child
      }, index);
    }) : children
  });
};
LabelGroup.displayName = 'LabelGroup';

export { LabelGroup as default };
